{"version":3,"sources":["../src/define-query-options.ts","../src/define-query.ts","../src/query-store.ts","../src/query-options.ts","../src/entry-keys.ts","../src/utils.ts","../src/use-query.ts","../src/use-query-state.ts","../src/infinite-query.ts","../src/mutation-store.ts","../src/mutation-options.ts","../src/use-mutation.ts","../src/define-mutation.ts","../src/devtools/plugin.ts","../src/pinia-colada.ts","../src/plugins/query-hooks.ts"],"sourcesContent":["import type { DefineQueryOptions } from './define-query'\nimport type { EntryKeyTagged } from './entry-keys'\nimport type { ErrorDefault } from './types-extension'\nimport { useQuery } from './use-query'\n\n/**\n * Tagged version of {@link DefineQueryOptions} that includes a key with\n * data type information.\n */\nexport interface DefineQueryOptionsTagged<\n  TData = unknown,\n  TError = ErrorDefault,\n  TDataInitial extends TData | undefined = undefined,\n> extends DefineQueryOptions<TData, TError, TDataInitial> {\n  key: EntryKeyTagged<TData, TError, TDataInitial>\n}\n\n/**\n * Define dynamic query options by passing a function that accepts an arbitrary\n * parameter and returns the query options. Enables type-safe query keys.\n * Must be passed to {@link useQuery} alongside a getter for the params.\n *\n * @param setupOptions - A function that returns the query options.\n */\nexport function defineQueryOptions<\n  Params,\n  TData,\n  TError = ErrorDefault,\n  TDataInitial extends TData | undefined = undefined,\n>(\n  setupOptions: (params: Params) => DefineQueryOptions<TData, TError, TDataInitial>,\n): (params: Params) => DefineQueryOptionsTagged<TData, TError, TDataInitial>\n\n/**\n * Define static query options that are type safe with\n * `queryCache.getQueryData()`. Can be passed directly to {@link useQuery}.\n *\n * @param options - The query options.\n */\nexport function defineQueryOptions<\n  TData,\n  TError = ErrorDefault,\n  TDataInitial extends TData | undefined = undefined,\n>(\n  options: DefineQueryOptions<TData, TError, TDataInitial>,\n): DefineQueryOptionsTagged<TData, TError, TDataInitial>\n\n/**\n * Define type-safe query options. Can be static or dynamic. Define the arguments based\n * on what's needed on the query and the key. Use an object if you need\n * multiple properties.\n *\n * @param setupOrOptions - The query options or a function that returns the query options.\n *\n * @example\n * ```ts\n * import { defineQueryOptions } from '@pinia/colada'\n *\n * const documentDetailsQuery = defineQueryOptions((id: number ) => ({\n *   key: ['documents', id],\n *   query: () => fetchDocument(id),\n * }))\n *\n * queryCache.getQueryData(documentDetailsQuery(4).key) // typed\n * ```\n *\n * @__NO_SIDE_EFFECTS__\n */\nexport function defineQueryOptions<const Options extends DefineQueryOptions, Params>(\n  setupOrOptions: Options | ((params: Params) => Options),\n): Options | ((params: Params) => Options) {\n  return setupOrOptions\n}\n","import { getCurrentInstance, getCurrentScope, onScopeDispose, toValue } from 'vue'\nimport type { EffectScope } from 'vue'\nimport type { UseQueryOptions } from './query-options'\nimport { useQueryCache } from './query-store'\nimport type { ErrorDefault } from './types-extension'\nimport type { UseQueryReturn } from './use-query'\nimport { useQuery } from './use-query'\nimport { noop } from './utils'\nimport type { _RemoveMaybeRef } from './utils'\n\n/**\n * The current effect scope where the function returned by `defineQuery` is\n * being called. This allows `useQuery()` to know if it should be attached to\n * an effect scope or not\n *\n * @internal\n */\n// eslint-disable-next-line import/no-mutable-exports\nexport let currentDefineQueryEffect: undefined | EffectScope\n\n/**\n * Options to define a query with `defineQuery()`. Similar to\n * {@link UseQueryOptions} but disallows reactive values as `defineQuery()` is\n * used outside of an effect scope.\n */\nexport type DefineQueryOptions<\n  TData = unknown,\n  TError = ErrorDefault,\n  TDataInitial extends TData | undefined = undefined,\n> = _RemoveMaybeRef<UseQueryOptions<TData, TError, TDataInitial>> & {\n  // NOTE: we need to duplicate the types for initialData and placeholderData to make everything work\n  // we omit the descriptions because they are inherited from the original type\n  initialData?: () => TDataInitial\n\n  placeholderData?:\n    | NoInfer<TDataInitial>\n    | NoInfer<TData>\n    | (<T extends TData>(\n        previousData: T | undefined,\n      ) => NoInfer<TDataInitial> | NoInfer<TData> | undefined)\n}\n\n/**\n * Define a query with the given options. Similar to `useQuery(options)` but\n * allows you to reuse **all** of the query state in multiple places. It only\n * allow static values in options. If you need dynamic values, use the function\n * version.\n *\n * @param options - the options to define the query\n *\n * @example\n * ```ts\n * const useTodoList = defineQuery({\n *   key: ['todos'],\n *   query: () => fetch('/api/todos', { method: 'GET' }),\n * })\n * ```\n */\nexport function defineQuery<TData, TError = ErrorDefault>(\n  options: DefineQueryOptions<TData, TError>,\n): () => UseQueryReturn<TData, TError>\n\n/**\n * Define a query with a setup function. Allows to return arbitrary values from\n * the query function, create contextual refs, rename the returned values, etc.\n * The setup function will be called only once, like stores, and **must be\n * synchronous**.\n *\n * @param setup - a function to setup the query\n *\n * @example\n * ```ts\n * const useFilteredTodos = defineQuery(() => {\n *   const todoFilter = ref<'all' | 'finished' | 'unfinished'>('all')\n *   const { data, ...rest } = useQuery({\n *    key: ['todos', { filter: todoFilter.value }],\n *     query: () =>\n *       fetch(`/api/todos?filter=${todoFilter.value}`, { method: 'GET' }),\n *   })\n *   // expose the todoFilter ref and rename data for convenience\n *   return { ...rest, todoList: data, todoFilter }\n * })\n * ```\n */\nexport function defineQuery<T>(setup: () => T): () => T\nexport function defineQuery(optionsOrSetup: DefineQueryOptions | (() => unknown)): () => unknown {\n  const setupFn\n    = typeof optionsOrSetup === 'function' ? optionsOrSetup : () => useQuery(optionsOrSetup)\n\n  let hasBeenEnsured: boolean | undefined\n  // allows pausing the scope when the defined query is no used anymore\n  let refCount = 0\n  return () => {\n    const queryCache = useQueryCache()\n    // preserve any current effect to account for nested usage of these functions\n    const previousEffect = currentDefineQueryEffect\n    const currentScope = getCurrentInstance() || (currentDefineQueryEffect = getCurrentScope())\n\n    const [ensuredEntries, ret, scope, isPaused] = queryCache.ensureDefinedQuery(setupFn)\n\n    // subsequent calls to the composable returned by useQuery will not trigger the `useQuery()`,\n    // this ensures the refetchOnMount option is respected\n    if (hasBeenEnsured) {\n      ensuredEntries.forEach((entry) => {\n        // since defined query can be activated multiple times without executing useQuery,\n        // we need to execute it here too\n        if (entry.options?.refetchOnMount && toValue(entry.options.enabled)) {\n          if (toValue(entry.options.refetchOnMount) === 'always') {\n            // we catch the error to avoid unhandled rejections\n            queryCache.fetch(entry).catch(noop)\n          } else {\n            queryCache.refresh(entry).catch(noop)\n          }\n        }\n      })\n    }\n    hasBeenEnsured = true\n\n    // NOTE: most of the time this should be set, so maybe we should show a dev warning\n    // if it's not set instead\n    //\n    // Because `useQuery()` might already be called before and we might be reusing an existing query\n    // we need to manually track and untrack. When untracking, we cannot use the ensuredEntries because\n    // there might be another component using the defineQuery, so we simply count how many are using it\n    if (currentScope) {\n      refCount++\n      ensuredEntries.forEach((entry) => {\n        queryCache.track(entry, currentScope)\n      })\n      onScopeDispose(() => {\n        ensuredEntries.forEach((entry) => {\n          queryCache.untrack(entry, currentScope)\n        })\n        // if all entries become inactive, we pause the scope\n        // to avoid triggering the effects within useQuery. This immitates the behavior\n        // of a component that unmounts\n        if (--refCount < 1) {\n          scope.pause()\n          isPaused.value = true\n        }\n      })\n    }\n\n    // reset the previous effect\n    currentDefineQueryEffect = previousEffect\n\n    return ret\n  }\n}\n","import { defineStore, getActivePinia, skipHydrate } from 'pinia'\nimport {\n  customRef,\n  effectScope,\n  getCurrentInstance,\n  getCurrentScope,\n  hasInjectionContext,\n  markRaw,\n  shallowRef,\n  toValue,\n} from 'vue'\nimport type { App, ComponentInternalInstance, EffectScope, ShallowRef } from 'vue'\nimport type { AsyncStatus, DataState } from './data-state'\nimport type { EntryKeyTagged, EntryKey } from './entry-keys'\nimport { useQueryOptions } from './query-options'\nimport type { UseQueryOptions, UseQueryOptionsWithDefaults } from './query-options'\nimport type { EntryFilter } from './entry-filter'\nimport { find, toCacheKey } from './entry-keys'\nimport type { ErrorDefault } from './types-extension'\nimport { noop, toValueWithArgs, warnOnce } from './utils'\n\n/**\n * Allows defining extensions to the query entry that are returned by `useQuery()`.\n */\n\nexport interface UseQueryEntryExtensions<\n  TData,\n  /* eslint-disable-next-line unused-imports/no-unused-vars */\n  TError,\n  /* eslint-disable-next-line unused-imports/no-unused-vars */\n  TDataInitial extends TData | undefined = undefined,\n> {}\n\n/**\n * NOTE: Entries could be classes but the point of having all functions within the store is to allow plugins to hook\n * into actions.\n */\n\n/**\n * A query entry in the cache.\n */\nexport interface UseQueryEntry<\n  TData = unknown,\n  TError = unknown,\n  // allows for UseQueryEntry to have unknown everywhere (generic version)\n  TDataInitial extends TData | undefined = unknown extends TData ? unknown : undefined,\n> {\n  /**\n   * The state of the query. Contains the data, error and status.\n   */\n  state: ShallowRef<DataState<TData, TError, TDataInitial>>\n\n  /**\n   * A placeholder `data` that is initially shown while the query is loading for the first time. This will also show the\n   * `status` as `success` until the query finishes loading (no matter the outcome).\n   */\n  placeholderData: TDataInitial | TData | null | undefined\n\n  /**\n   * The status of the query.\n   */\n  asyncStatus: ShallowRef<AsyncStatus>\n\n  /**\n   * When was this data set in the entry for the last time in ms. It can also\n   * be 0 if the entry has been invalidated.\n   */\n  when: number\n\n  /**\n   * The serialized key associated with this query entry.\n   */\n  key: EntryKey\n\n  /**\n   * Seriaized version of the key. Used to retrieve the entry from the cache.\n   */\n  keyHash: string\n\n  /**\n   * Components and effects scopes that use this query entry.\n   */\n  deps: Set<EffectScope | ComponentInternalInstance>\n\n  /**\n   * Timeout id that scheduled a garbage collection. It is set here to clear it when the entry is used by a different component\n   */\n  gcTimeout: ReturnType<typeof setTimeout> | undefined\n\n  /**\n   * The current pending request.\n   */\n  pending: null | {\n    /**\n     * The abort controller used to cancel the request and which `signal` is passed to the query function.\n     */\n    abortController: AbortController\n    /**\n     * The promise created by `queryCache.fetch` that is currently pending.\n     */\n    refreshCall: Promise<DataState<TData, TError, TDataInitial>>\n    /**\n     * When was this `pending` object created.\n     */\n    when: number\n  }\n\n  /**\n   * Options used to create the query. They can be `null` during hydration but are needed for fetching. This is why\n   * `store.ensure()` sets this property. Note these options might be shared by multiple query entries when the key is\n   * dynamic and that's why some methods like {@link fetch} receive the options as an argument.\n   */\n  options: UseQueryOptionsWithDefaults<TData, TError, TDataInitial> | null\n\n  /**\n   * Whether the data is stale or not, requires `options.staleTime` to be set.\n   */\n  readonly stale: boolean\n\n  /**\n   * Whether the query is currently being used by a Component or EffectScope (e.g. a store).\n   */\n  readonly active: boolean\n\n  /**\n   * Extensions to the query entry added by plugins.\n   */\n  ext: UseQueryEntryExtensions<TData, TError, TDataInitial>\n\n  /**\n   * Internal property to store the HMR ids of the components that are using\n   * this query and force refetching.\n   *\n   * @internal\n   */\n  __hmr?: {\n    /**\n     * Reference count of the components using this query.\n     */\n    ids: Map<string, number>\n  }\n}\n\n/**\n * Keep track of the entry being defined so we can add the queries in ensure\n * this allows us to refresh the entry when a defined query is used again\n * and refetchOnMount is true\n *\n * @internal\n */\n// eslint-disable-next-line import/no-mutable-exports\nexport let currentDefineQueryEntry: DefineQueryEntry | undefined | null\n\n/**\n * Returns whether the entry is using a placeholder data.\n *\n * @template TDataInitial - Initial data type\n * @param entry - entry to check\n */\nexport function isEntryUsingPlaceholderData<TDataInitial>(\n  entry: UseQueryEntry<unknown, unknown, TDataInitial> | undefined | null,\n): entry is UseQueryEntry<unknown, unknown, TDataInitial> & { placeholderData: TDataInitial } {\n  return entry?.placeholderData != null && entry.state.value.status === 'pending'\n}\n\n/**\n * Filter object to get entries from the query cache.\n *\n * @see {@link QueryCache.getEntries}\n * @see {@link QueryCache.cancelQueries}\n * @see {@link QueryCache#invalidateQueries}\n */\nexport type UseQueryEntryFilter = EntryFilter<UseQueryEntry>\n\n/**\n * Empty starting object for extensions that allows to detect when to update.\n *\n * @internal\n */\nexport const START_EXT = {}\n\n/**\n * UseQueryEntry method to serialize the entry to JSON.\n *\n * @param entry - entry to serialize\n * @param entry.when - when the data was fetched the last time\n * @param entry.state - data state of the entry\n * @param entry.state.value - value of the data state\n * @returns Serialized version of the entry\n */\nexport const queryEntry_toJSON: <TData, TError>(\n  entry: UseQueryEntry<TData, TError>,\n) => _UseQueryEntryNodeValueSerialized<TData, TError> = ({ state: { value }, when }) => [\n  value.data,\n  value.error,\n  // because of time zones, we create a relative time\n  when ? Date.now() - when : -1,\n]\n// TODO: errors are not serializable by default. We should provide a way to serialize custom errors and, by default provide one that serializes the name and message\n\n/**\n * UseQueryEntry method to serialize the entry to a string.\n *\n * @internal\n * @param entry - entry to serialize\n * @returns Stringified version of the entry\n */\nexport const queryEntry_toString: <TData, TError>(entry: UseQueryEntry<TData, TError>) => string = (\n  entry,\n) => String(queryEntry_toJSON(entry))\n\n/**\n * The id of the store used for queries.\n * @internal\n */\nexport const QUERY_STORE_ID = '_pc_query'\n\n/**\n * A query entry that is defined with {@link defineQuery}.\n * @internal\n */\ntype DefineQueryEntry = [\n  lastEnsuredEntries: UseQueryEntry[],\n  returnValue: unknown,\n  effect: EffectScope,\n  paused: ShallowRef<boolean>,\n]\n\n/**\n * Composable to get the cache of the queries. As any other composable, it can be used inside the `setup` function of a\n * component, within another composable, or in injectable contexts like stores and navigation guards.\n */\nexport const useQueryCache = /* @__PURE__ */ defineStore(QUERY_STORE_ID, ({ action }) => {\n  // We have two versions of the cache, one that track changes and another that doesn't so the actions can be used\n  // inside computed properties\n  const cachesRaw = new Map<string, UseQueryEntry<unknown, unknown, unknown>>()\n  let triggerCache!: () => void\n  const caches = skipHydrate(\n    customRef(\n      (track, trigger) =>\n        (triggerCache = trigger) && {\n          // eslint-disable-next-line no-sequences\n          get: () => (track(), cachesRaw),\n          set:\n            process.env.NODE_ENV !== 'production'\n              ? () => {\n                  console.error(\n                    `[@pinia/colada]: The query cache instance cannot be set directly, it must be modified. This will fail in production.`,\n                  )\n                }\n              : noop,\n        },\n    ),\n  )\n\n  // this version of the cache cannot be hydrated because it would miss all of the actions\n  // and plugins won't be able to hook into entry creation and fetching\n  // this allows use to attach reactive effects to the scope later on\n  const scope = getCurrentScope()!\n  const app: App<unknown>\n    // @ts-expect-error: internal\n    = getActivePinia()!._a\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!hasInjectionContext()) {\n      warnOnce(\n        `useQueryCache() was called outside of an injection context (component setup, store, navigation guard) You will get a warning about \"inject\" being used incorrectly from Vue. Make sure to use it only in allowed places.\\n`\n          + `See https://vuejs.org/guide/reusability/composables.html#usage-restrictions`,\n      )\n    }\n  }\n\n  const optionDefaults = useQueryOptions()\n\n  /**\n   * Creates a new query entry in the cache. Shouldn't be called directly.\n   *\n   * @param key - Serialized key of the query\n   * @param [options] - options attached to the query\n   * @param [initialData] - initial data of the query if any\n   * @param [error] - initial error of the query if any\n   * @param [when] - relative when was the data or error fetched (will be added to Date.now())\n   */\n  const create = action(\n    <TData, TError, TDataInitial extends TData | undefined>(\n      key: EntryKey,\n      options: UseQueryOptionsWithDefaults<TData, TError, TDataInitial> | null = null,\n      initialData?: TDataInitial,\n      error: TError | null = null,\n      when: number = 0,\n      // when: number = initialData === undefined ? 0 : Date.now(),\n    ): UseQueryEntry<TData, TError, TDataInitial> =>\n      scope.run(() => {\n        const state = shallowRef<DataState<TData, TError, TDataInitial>>(\n          // @ts-expect-error: to make the code shorter we are using one declaration instead of multiple ternaries\n          {\n            // NOTE: we could move the `initialData` parameter before `options` and make it required\n            // but that would force `create` call in `setQueryData` to pass an extra `undefined` argument\n            data: initialData as TDataInitial,\n            error,\n            status: error ? 'error' : initialData !== undefined ? 'success' : 'pending',\n          },\n        )\n        const asyncStatus = shallowRef<AsyncStatus>('idle')\n        // we markRaw to avoid unnecessary vue traversal\n        return markRaw<UseQueryEntry<TData, TError, TDataInitial>>({\n          key,\n          keyHash: toCacheKey(key),\n          state,\n          placeholderData: null,\n          when: initialData === undefined ? 0 : Date.now() - when,\n          asyncStatus,\n          pending: null,\n          // this set can contain components and effects and worsen the performance\n          // and create weird warnings\n          deps: markRaw(new Set()),\n          gcTimeout: undefined,\n          // eslint-disable-next-line ts/ban-ts-comment\n          // @ts-ignore: some plugins are adding properties to the entry type\n          ext: START_EXT,\n          options,\n          get stale() {\n            return !this.options || !this.when || Date.now() >= this.when + this.options.staleTime\n          },\n          get active() {\n            return this.deps.size > 0\n          },\n        } satisfies UseQueryEntry<TData, TError, TDataInitial>)\n      })!,\n  )\n\n  const defineQueryMap = new WeakMap<() => unknown, DefineQueryEntry>()\n\n  /**\n   * Ensures a query created with {@link defineQuery} is present in the cache. If it's not, it creates a new one.\n   * @param fn - function that defines the query\n   */\n  const ensureDefinedQuery = action(<T>(fn: () => T) => {\n    let defineQueryEntry = defineQueryMap.get(fn)\n    if (!defineQueryEntry) {\n      // create the entry first\n      currentDefineQueryEntry = defineQueryEntry = scope.run(() => [\n        [],\n        null,\n        effectScope(),\n        shallowRef(false),\n      ])!\n\n      // then run it so it can add the queries to the entry\n      // we use the app context for injections and the scope for effects\n      defineQueryEntry[1] = app.runWithContext(() => defineQueryEntry![2].run(fn)!)\n      currentDefineQueryEntry = null\n      defineQueryMap.set(fn, defineQueryEntry)\n    } else {\n      // ensure the scope is active so effects computing inside `useQuery()` run (e.g. the entry computed)\n      defineQueryEntry[2].resume()\n      defineQueryEntry[3].value = false\n      // if the entry already exists, we know the queries inside\n      // we should consider as if they are activated again\n      defineQueryEntry[0] = defineQueryEntry[0].map((oldEntry) =>\n        // the entries' key might have changed (e.g. Nuxt navigation)\n        // so we need to ensure them again\n        oldEntry.options ? ensure(oldEntry.options, oldEntry) : oldEntry,\n      )\n    }\n\n    return defineQueryEntry\n  })\n\n  /**\n   * Tracks an effect or component that uses a query.\n   *\n   * @param entry - the entry of the query\n   * @param effect - the effect or component to untrack\n   *\n   * @see {@link untrack}\n   */\n  function track(\n    entry: UseQueryEntry,\n    effect: EffectScope | ComponentInternalInstance | null | undefined,\n  ) {\n    if (!effect) return\n    entry.deps.add(effect)\n    // clearTimeout ignores anything that isn't a timerId\n    clearTimeout(entry.gcTimeout)\n    entry.gcTimeout = undefined\n    triggerCache()\n  }\n\n  /**\n   * Untracks an effect or component that uses a query.\n   *\n   * @param entry - the entry of the query\n   * @param effect - the effect or component to untrack\n   *\n   * @see {@link track}\n   */\n  function untrack(\n    entry: UseQueryEntry,\n    effect: EffectScope | ComponentInternalInstance | undefined | null,\n  ) {\n    // avoid clearing an existing timeout\n    if (!effect || !entry.deps.has(effect)) return\n\n    // clear any HMR to avoid letting the set grow\n    if (process.env.NODE_ENV !== 'production') {\n      if ('type' in effect && '__hmrId' in effect.type && entry.__hmr) {\n        const count = (entry.__hmr.ids.get(effect.type.__hmrId) ?? 1) - 1\n        if (count > 0) {\n          entry.__hmr.ids.set(effect.type.__hmrId, count)\n        } else {\n          entry.__hmr.ids.delete(effect.type.__hmrId)\n        }\n      }\n    }\n\n    entry.deps.delete(effect)\n    triggerCache()\n\n    scheduleGarbageCollection(entry)\n  }\n\n  function scheduleGarbageCollection(entry: UseQueryEntry) {\n    // schedule a garbage collection if the entry is not active\n    // and we know its gcTime value\n    if (entry.deps.size > 0 || !entry.options) return\n    clearTimeout(entry.gcTimeout)\n    // avoid setting a timeout with false, Infinity or NaN\n    if ((Number.isFinite as (val: unknown) => val is number)(entry.options.gcTime)) {\n      entry.gcTimeout = setTimeout(() => {\n        remove(entry)\n      }, entry.options.gcTime)\n    }\n  }\n\n  /**\n   * Invalidates and cancel matched queries, and then refetches (in parallel)\n   * all active ones. If you need to further control which queries are\n   * invalidated, canceled, and/or refetched, you can use the filters, you\n   * can direcly call {@link invalidate} on {@link getEntries}:\n   *\n   * ```ts\n   * // instead of doing\n   * await queryCache.invalidateQueries(filters)\n   * await Promise.all(queryCache.getEntries(filters).map(entry => {\n   *   queryCache.invalidate(entry)\n   *   // this is the default behavior of invalidateQueries\n   *   // return entry.active && queryCache.fetch(entry)\n   *   // here to refetch everything, even non active queries\n   *   return queryCache.fetch(entry)\n   * })\n   * ```\n   *\n   * @param filters - filters to apply to the entries\n   * @param refetchActive - whether to refetch active queries or not. Set\n   * to `'all'` to refetch all queries\n   *\n   * @see {@link invalidate}\n   * @see {@link cancel}\n   */\n  const invalidateQueries = action(\n    (filters?: UseQueryEntryFilter, refetchActive: boolean | 'all' = true): Promise<unknown> => {\n      return Promise.all(\n        getEntries(filters).map((entry) => {\n          invalidate(entry)\n          return (\n            (refetchActive === 'all' || (entry.active && refetchActive))\n            && toValue(entry.options?.enabled)\n            && fetch(entry)\n          )\n        }),\n      )\n    },\n  )\n\n  /**\n   * Returns all the entries in the cache that match the filters.\n   *\n   * @param filters - filters to apply to the entries\n   */\n  const getEntries = action((filters: UseQueryEntryFilter = {}): UseQueryEntry[] => {\n    // TODO: Iterator.from(node) in 2028 once widely available? or maybe not worth it\n    return (\n      filters.exact\n        ? filters.key\n          ? [caches.value.get(toCacheKey(filters.key))].filter((v) => !!v)\n          : [] // exact with no key can't match anything\n        : [...find(caches.value, filters.key)]\n    ).filter(\n      (entry) =>\n        (filters.stale == null || entry.stale === filters.stale)\n        && (filters.active == null || entry.active === filters.active)\n        && (!filters.status || entry.state.value.status === filters.status)\n        && (!filters.predicate || filters.predicate(entry)),\n    )\n  })\n\n  /**\n   * Ensures a query entry is present in the cache. If it's not, it creates a new one. The resulting entry is required\n   * to call other methods like {@link fetch}, {@link refresh}, or {@link invalidate}.\n   *\n   * @param opts - options to create the query\n   * @param previousEntry - the previous entry that was associated with the same options\n   */\n  const ensure = action(\n    <TData = unknown, TError = ErrorDefault, TDataInitial extends TData | undefined = undefined>(\n      opts: UseQueryOptions<TData, TError, TDataInitial>,\n      previousEntry?: UseQueryEntry<TData, TError, TDataInitial>,\n    ): UseQueryEntry<TData, TError, TDataInitial> => {\n      const options: UseQueryOptionsWithDefaults<TData, TError, TDataInitial> = {\n        ...optionDefaults,\n        ...opts,\n      }\n      const key = toValue(options.key)\n      const keyHash = toCacheKey(key)\n\n      if (process.env.NODE_ENV !== 'production' && keyHash === '[]') {\n        throw new Error(\n          `useQuery() was called with an empty array as the key. It must have at least one element.`,\n        )\n      }\n\n      // do not reinitialize the entry\n      // because of the immediate watcher in useQuery, the `ensure()` action is called twice on mount\n      // we return early to avoid pushing to currentDefineQueryEntry\n      if (previousEntry && keyHash === previousEntry.keyHash) {\n        return previousEntry\n      }\n\n      // Since ensure() is called within a computed, we cannot let Vue track cache, so we use the raw version instead\n      let entry = cachesRaw.get(keyHash) as UseQueryEntry<TData, TError, TDataInitial> | undefined\n      // ensure the state\n      if (!entry) {\n        cachesRaw.set(keyHash, (entry = create(key, options, options.initialData?.())))\n        // the placeholderData is only used if the entry is initially loading\n        if (options.placeholderData && entry.state.value.status === 'pending') {\n          entry.placeholderData = toValueWithArgs(\n            options.placeholderData,\n            // pass the previous entry placeholder data if it was in placeholder state\n            isEntryUsingPlaceholderData(previousEntry)\n              ? previousEntry.placeholderData\n              : previousEntry?.state.value.data,\n          )\n        }\n        triggerCache()\n      }\n\n      // during HMR, staleTime could be long and if we change the query function, the query won't trigger a refetch\n      // so we need to detect and trigger just in case\n      if (process.env.NODE_ENV !== 'production') {\n        const currentInstance = getCurrentInstance()\n        if (currentInstance) {\n          entry.__hmr ??= { ids: new Map() }\n\n          const id\n            // @ts-expect-error: internal property\n            = currentInstance.type?.__hmrId\n\n          if (id) {\n            if (entry.__hmr.ids.has(id)) {\n              invalidate(entry)\n            }\n            const count = (entry.__hmr.ids.get(id) ?? 0) + 1\n            entry.__hmr.ids.set(id, count)\n          }\n        }\n      }\n\n      // we set it every time to ensure we are using up to date key getters and others options\n      entry.options = options\n\n      // extend the entry with plugins the first time only\n      if (entry.ext === START_EXT) {\n        entry.ext = {} as UseQueryEntryExtensions<TData, TError>\n        extend(entry)\n      }\n\n      // if this query was defined within a defineQuery call, add it to the list\n      currentDefineQueryEntry?.[0].push(entry)\n\n      return entry\n    },\n  )\n\n  /**\n   * Action called when an entry is ensured for the first time to allow plugins to extend it.\n   *\n   * @param _entry - the entry of the query to extend\n   */\n  const extend = action(\n    <TData = unknown, TError = ErrorDefault, TDataInitial extends TData | undefined = undefined>(\n      _entry: UseQueryEntry<TData, TError, TDataInitial>,\n    ) => {},\n  )\n\n  /**\n   * Invalidates and cancels a query entry. It effectively sets the `when`\n   * property to `0` and {@link cancel | cancels} the pending request.\n   *\n   * @param entry - the entry of the query to invalidate\n   *\n   * @see {@link cancel}\n   */\n  const invalidate = action((entry: UseQueryEntry) => {\n    // will force a fetch next time\n    entry.when = 0\n    // ignores the pending query\n    cancel(entry)\n  })\n\n  /**\n   * Ensures the current data is fresh. If the data is stale or if the status\n   * is 'error', calls {@link fetch}, if not return the current data. Can only\n   * be called if the entry has been initialized with `useQuery()` and has\n   * options.\n   *\n   * @param entry - the entry of the query to refresh\n   * @param options - the options to use for the fetch\n   *\n   * @see {@link fetch}\n   */\n  const refresh = action(\n    async <TData, TError, TDataInitial extends TData | undefined>(\n      entry: UseQueryEntry<TData, TError, TDataInitial>,\n      options = entry.options,\n    ): Promise<DataState<TData, TError, TDataInitial>> => {\n      if (process.env.NODE_ENV !== 'production' && !options) {\n        throw new Error(\n          `\"entry.refresh()\" was called but the entry has no options. This is probably a bug, report it to pinia-colada with a boiled down example to reproduce it. Thank you!`,\n        )\n      }\n\n      if (entry.state.value.error || entry.stale) {\n        return entry.pending?.refreshCall ?? fetch(entry, options)\n      }\n\n      return entry.state.value\n    },\n  )\n\n  /**\n   * Fetch an entry. Ignores fresh data and triggers a new fetch. Can only be called if the entry has options.\n   *\n   * @param entry - the entry of the query to fetch\n   * @param options - the options to use for the fetch\n   */\n  const fetch = action(\n    async <TData, TError, TDataInitial extends TData | undefined>(\n      entry: UseQueryEntry<TData, TError, TDataInitial>,\n      options = entry.options,\n    ): Promise<DataState<TData, TError, TDataInitial>> => {\n      if (process.env.NODE_ENV !== 'production' && !options) {\n        throw new Error(\n          `\"entry.fetch()\" was called but the entry has no options. This is probably a bug, report it to pinia-colada with a boiled down example to reproduce it. Thank you!`,\n        )\n      }\n\n      entry.asyncStatus.value = 'loading'\n\n      const abortController = new AbortController()\n      const { signal } = abortController\n      // Abort any ongoing request without a reason to keep `AbortError` even with\n      // signal.throwIfAborted() in the query function\n      entry.pending?.abortController.abort()\n\n      const pendingCall = (entry.pending = {\n        abortController,\n        // wrapping with async allows us to catch synchronous errors too\n        refreshCall: (async () => options!.query({ signal }))()\n          .then((data) => {\n            if (pendingCall === entry.pending) {\n              setEntryState(entry, {\n                data,\n                error: null,\n                status: 'success',\n              })\n            }\n            return entry.state.value\n          })\n          .catch((error) => {\n            if (\n              pendingCall === entry.pending\n              && error\n              // when the error is an abort error, it means the request was cancelled\n              // we should just ignore the result of the query but not error\n              && error.name !== 'AbortError'\n            ) {\n              setEntryState(entry, {\n                status: 'error',\n                data: entry.state.value.data,\n                error,\n              })\n            }\n\n            // always propagate up the error\n            throw error\n            // NOTE: other options included returning an ongoing request if the error was a cancellation but it seems not worth it\n          })\n          .finally(() => {\n            entry.asyncStatus.value = 'idle'\n            if (pendingCall === entry.pending) {\n              // update the time amounts based on the current request\n              // NOTE: Normally these should be the same everywhere but the\n              // same query could be instantiated with different options\n              // entry.gcTime = options!.gcTime\n              // entry.staleTime = options!.staleTime\n              entry.pending = null\n              // there are cases when the result is ignored, in that case, we still\n              // do not have a real result so we keep the placeholder data\n              if (entry.state.value.status !== 'pending') {\n                // reset the placeholder data to free up memory\n                entry.placeholderData = null\n              }\n              entry.when = Date.now()\n            }\n          }),\n        when: Date.now(),\n      })\n\n      return pendingCall.refreshCall\n    },\n  )\n\n  /**\n   * Cancels an entry's query if it's currently pending. This will effectively abort the `AbortSignal` of the query and any\n   * pending request will be ignored.\n   *\n   * @param entry - the entry of the query to cancel\n   * @param reason - the reason passed to the abort controller\n   */\n  const cancel = action((entry: UseQueryEntry, reason?: unknown) => {\n    entry.pending?.abortController.abort(reason)\n    // eagerly set the status to idle because the abort signal might not\n    // be consumed by the user's query\n    entry.asyncStatus.value = 'idle'\n    entry.pending = null\n  })\n\n  /**\n   * Cancels queries if they are currently pending. This will effectively abort the `AbortSignal` of the query and any\n   * pending request will be ignored.\n   *\n   * @param filters - filters to apply to the entries\n   * @param reason - the reason passed to the abort controller\n   *\n   * @see {@link cancel}\n   */\n  const cancelQueries = action((filters?: UseQueryEntryFilter, reason?: unknown) => {\n    getEntries(filters).forEach((entry) => cancel(entry, reason))\n  })\n\n  /**\n   * Sets the state of a query entry in the cache and updates the\n   * {@link UseQueryEntry['pending']['when'] | `when` property}. This action is\n   * called every time the cache state changes and can be used by plugins to\n   * detect changes.\n   *\n   * @param entry - the entry of the query to set the state\n   * @param state - the new state of the entry\n   */\n  const setEntryState = action(\n    <TData, TError, TDataInitial extends TData | undefined = TData | undefined>(\n      entry: UseQueryEntry<TData, TError, TDataInitial>,\n      // NOTE: NoInfer ensures correct inference of TData and TError\n      state: DataState<NoInfer<TData>, NoInfer<TError>, NoInfer<TDataInitial>>,\n    ) => {\n      entry.state.value = state\n      entry.when = Date.now()\n      // if we need to, we could schedule a garbage collection here but I don't\n      // see why would one create entries that are not used (not tracked immediately after)\n    },\n  )\n\n  /**\n   * Gets a single query entry from the cache based on the key of the query.\n   *\n   * @param key - the key of the query\n   */\n  function get<\n    TData = unknown,\n    TError = ErrorDefault,\n    TDataInitial extends TData | undefined = undefined,\n  >(\n    key: EntryKeyTagged<TData, TError, TDataInitial> | EntryKey,\n  ): UseQueryEntry<TData, TError, TDataInitial> | undefined {\n    return caches.value.get(toCacheKey(key)) as\n      | UseQueryEntry<TData, TError, TDataInitial>\n      | undefined\n  }\n\n  /**\n   * Set the data of a query entry in the cache. It also sets the `status` to `success`.\n   *\n   * @param key - the key of the query\n   * @param data - the new data to set\n   *\n   * @see {@link setEntryState}\n   */\n  const setQueryData = action(\n    <TData = unknown, TError = ErrorDefault, TDataInitial extends TData | undefined = undefined>(\n      key: EntryKeyTagged<TData, TError, TDataInitial> | EntryKey,\n      data:\n        | NoInfer<TData>\n        // a success query cannot have undefined data\n        | Exclude<NoInfer<TDataInitial>, undefined>\n        // but could not be there and therefore have undefined here\n        | ((oldData: TData | TDataInitial | undefined) => TData | Exclude<TDataInitial, undefined>),\n    ) => {\n      const keyHash = toCacheKey(key)\n      let entry = cachesRaw.get(keyHash) as UseQueryEntry<TData, unknown, TDataInitial> | undefined\n\n      // if the entry doesn't exist, we create it to set the data\n      // it cannot be refreshed or fetched since the options\n      // will be missing\n      if (!entry) {\n        cachesRaw.set(keyHash, (entry = create<TData, unknown, TDataInitial>(key)))\n      }\n\n      setEntryState(entry, {\n        // we assume the data accounts for a successful state\n        error: null,\n        status: 'success',\n        data: toValueWithArgs(data, entry.state.value.data),\n      })\n      scheduleGarbageCollection(entry)\n      triggerCache()\n    },\n  )\n\n  /**\n   * Sets the data of all queries in the cache that are children of a key. It\n   * also sets the `status` to `success`. Differently from {@link\n   * setQueryData}, this method recursively sets the data for all queries. This\n   * is why it requires a function to set the data.\n   *\n   * @param filters - filters used to get the entries\n   * @param updater - the function to set the data\n   *\n   * @example\n   * ```ts\n   * // let's suppose we want to optimistically update all contacts in the cache\n   * setQueriesData(['contacts', 'list'], (contactList: Contact[]) => {\n   *   const contactToReplaceIndex = contactList.findIndex(c => c.id === updatedContact.id)\n   *   return contactList.toSpliced(contactToReplaceIndex, 1, updatedContact)\n   * })\n   * ```\n   *\n   * @see {@link setQueryData}\n   */\n  function setQueriesData<TData = unknown>(\n    filters: UseQueryEntryFilter,\n    updater: (previous: TData | undefined) => TData,\n  ): void {\n    for (const entry of getEntries(filters)) {\n      setEntryState(entry, {\n        error: null,\n        status: 'success',\n        data: updater(entry.state.value.data as TData | undefined),\n      })\n      scheduleGarbageCollection(entry)\n    }\n    triggerCache()\n  }\n\n  /**\n   * Gets the data of a query entry in the cache based on the key of the query.\n   *\n   * @param key - the key of the query\n   */\n  function getQueryData<\n    TData = unknown,\n    TError = ErrorDefault,\n    TDataInitial extends TData | undefined = undefined,\n  >(key: EntryKeyTagged<TData, TError, TDataInitial> | EntryKey): TData | TDataInitial | undefined {\n    return caches.value.get(toCacheKey(key))?.state.value.data as TData | TDataInitial | undefined\n  }\n\n  /**\n   * Removes a query entry from the cache.\n   *\n   * @param entry - the entry of the query to remove\n   */\n  const remove = action((entry: UseQueryEntry) => {\n    // setting without a value is like setting it to undefined\n    cachesRaw.delete(entry.keyHash)\n    triggerCache()\n  })\n\n  return {\n    caches,\n\n    ensureDefinedQuery,\n    /**\n     * Scope to track effects and components that use the query cache.\n     * @internal\n     */\n    _s: markRaw(scope),\n    setQueryData,\n    setQueriesData,\n    getQueryData,\n\n    invalidateQueries,\n    cancelQueries,\n\n    // Actions for entries\n    invalidate,\n    fetch,\n    refresh,\n    ensure,\n    extend,\n    track,\n    untrack,\n    cancel,\n    create,\n    remove,\n    get,\n    setEntryState,\n    getEntries,\n  }\n})\n\n/**\n * The cache of the queries. It's the store returned by {@link useQueryCache}.\n */\nexport type QueryCache = ReturnType<typeof useQueryCache>\n\n/**\n * Checks if the given object is a query cache. Used in SSR to apply custom serialization.\n *\n * @param cache - the object to check\n *\n * @see {@link QueryCache}\n * @see {@link serializeQueryCache}\n */\nexport function isQueryCache(cache: unknown): cache is QueryCache {\n  return (\n    typeof cache === 'object'\n    && !!cache\n    && (cache as Record<string, unknown>).$id === QUERY_STORE_ID\n  )\n}\n\n/**\n * Raw data of a query entry. Can be serialized from the server and used to\n * hydrate the store.\n *\n * @internal\n */\nexport type _UseQueryEntryNodeValueSerialized<TData = unknown, TError = unknown> = [\n  /**\n   * The data returned by the query.\n   */\n  data: TData | undefined,\n\n  /**\n   * The error thrown by the query.\n   */\n  error: TError | null,\n\n  /**\n   * When was this data fetched the last time in ms\n   */\n  when?: number,\n]\n\n/**\n * Hydrates the query cache with the serialized cache. Used during SSR.\n * @param queryCache - query cache\n * @param serializedCache - serialized cache\n */\nexport function hydrateQueryCache(\n  queryCache: QueryCache,\n  serializedCache: Record<string, _UseQueryEntryNodeValueSerialized>,\n) {\n  for (const keyHash in serializedCache) {\n    queryCache.caches.set(\n      keyHash,\n      queryCache.create(JSON.parse(keyHash), undefined, ...(serializedCache[keyHash] ?? [])),\n    )\n  }\n}\n\n/**\n * Serializes the query cache to a compressed version. Used during SSR.\n *\n * @param queryCache - query cache\n */\nexport function serializeQueryCache(\n  queryCache: QueryCache,\n): Record<string, _UseQueryEntryNodeValueSerialized> {\n  return Object.fromEntries(\n    // TODO: 2028: directly use .map on the iterator\n    [...queryCache.caches.entries()].map(([keyHash, entry]) => [keyHash, queryEntry_toJSON(entry)]),\n  )\n}\n","import { inject } from 'vue'\nimport type { InjectionKey, MaybeRefOrGetter } from 'vue'\nimport type { EntryKey } from './entry-keys'\nimport type { ErrorDefault } from './types-extension'\n\n/**\n * Possible values for `refetchOnMount`, `refetchOnWindowFocus`, and `refetchOnReconnect`.\n * `true` refetches if data is stale (calles `refresh()`), `false` never refetches, `'always'` always refetches.\n */\nexport type RefetchOnControl = boolean | 'always'\n\n/**\n * Options for queries that can be globally overridden.\n */\nexport interface UseQueryOptionsGlobal {\n  /**\n   * Whether the query should be enabled or not. If `false`, the query will not\n   * be executed until `refetch()` or `refresh()` is called. If it becomes\n   * `true`, the query will be refreshed.\n   */\n  enabled?: MaybeRefOrGetter<boolean>\n\n  /**\n   * Time in ms after which the data is considered stale and will be refreshed\n   * on next read.\n   *\n   * @default 5000 (5 seconds)\n   */\n  staleTime?: number\n\n  /**\n   * Time in ms after which, once the data is no longer being used, it will be\n   * garbage collected to free resources. Set to `false` to disable garbage\n   * collection.\n   *\n   * @default 300_000 (5 minutes)\n   */\n  gcTime?: number | false\n\n  /**\n   * Whether to refetch the query when the component is mounted.\n   * @default true\n   */\n  refetchOnMount?: MaybeRefOrGetter<RefetchOnControl>\n\n  /**\n   * Whether to refetch the query when the window regains focus.\n   * @default true\n   */\n  refetchOnWindowFocus?: MaybeRefOrGetter<RefetchOnControl>\n\n  /**\n   * Whether to refetch the query when the network reconnects.\n   * @default true\n   */\n  refetchOnReconnect?: MaybeRefOrGetter<RefetchOnControl>\n\n  /**\n   * A placeholder data that is initially shown while the query is loading for\n   * the first time. This will also show the `status` as `success` until the\n   * query finishes loading (no matter the outcome of the query). Note: unlike\n   * with `initialData`, the placeholder does not change the cache state.\n   */\n  placeholderData?: (previousData: unknown) => any // any allows us to not worry about the types when merging options\n}\n\n/**\n * Context object passed to the `query` function of `useQuery()`.\n * @see {@link UseQueryOptions}\n */\nexport interface UseQueryFnContext {\n  /**\n   * `AbortSignal` instance attached to the query call. If the call becomes\n   * outdated (e.g. due to a new call with the same key), the signal will be\n   * aborted.\n   */\n  signal: AbortSignal\n}\n\n/**\n * Options for `useQuery()`. Can be extended by plugins.\n *\n * @example\n * ```ts\n * // use-query-plugin.d.ts\n * export {} // needed\n * declare module '@pinia/colada' {\n *   interface UseQueryOptions {\n *     // Whether to refresh the data when the component is mounted.\n *     refreshOnMount?: boolean\n *   }\n * }\n * ```\n */\nexport interface UseQueryOptions<\n  TData = unknown,\n  // eslint-disable-next-line unused-imports/no-unused-vars\n  TError = ErrorDefault,\n  TDataInitial extends TData | undefined = undefined,\n> extends Pick<\n    UseQueryOptionsGlobal,\n    | 'gcTime'\n    | 'enabled'\n    | 'refetchOnMount'\n    | 'refetchOnReconnect'\n    | 'refetchOnWindowFocus'\n    | 'staleTime'\n  > {\n  /**\n   * The key used to identify the query. Array of primitives **without**\n   * reactive values or a reactive array or getter. It should be treaded as an\n   * array of dependencies of your queries, e.g. if you use the\n   * `route.params.id` property, it should also be part of the key:\n   *\n   * ```ts\n   * import { useRoute } from 'vue-router'\n   * import { useQuery } from '@pinia/colada'\n   *\n   * const route = useRoute()\n   * const { data } = useQuery({\n   *   // pass a getter function (or computed, ref, etc.) to ensure reactivity\n   *   key: () => ['user', route.params.id],\n   *   query: () => fetchUser(route.params.id),\n   * })\n   * ```\n   */\n  key: MaybeRefOrGetter<EntryKey>\n\n  /**\n   * The function that will be called to fetch the data. It **must** be async.\n   */\n  query: (context: UseQueryFnContext) => Promise<TData>\n\n  /**\n   * The data which is initially set to the query while the query is loading\n   * for the first time. Note: unlike with {@link placeholderData}, setting the\n   * initial data changes the state of the query (it will be set to `success`).\n   *\n   * @see {@link placeholderData}\n   */\n  initialData?: () => TDataInitial\n\n  /**\n   * A placeholder data that is initially shown while the query is loading for\n   * the first time. This will also show the `status` as `success` until the\n   * query finishes loading (no matter the outcome of the query). Note: unlike\n   * with {@link initialData}, the placeholder does not change the cache state.\n   *\n   * @see {@link initialData}\n   */\n  placeholderData?:\n    | NoInfer<TDataInitial>\n    | NoInfer<TData>\n    // NOTE: the generic here allows to make UseQueryOptions<T> assignable to UseQueryOptions<unknown>\n    // https://www.typescriptlang.org/play/?#code/JYOwLgpgTgZghgYwgAgPIAczAPYgM4A8AKsgLzICuIA1iNgO4gB8yA3gFDLICOAXMgAoAlGRYAFKNgC2wPBGJNOydAH5eSrgHpNyABZwAbqADmyMLpRwoxilIjhkAIygQ41PMmBgNyAD6CBdBcjbAo8ABE4MDh+ADlsAEkQGGgFP0oQABMIGFAITJFSFniklKgFIR9tZCJdWWQDaDwcEGR6bCh3Kp1-AWISCAAPSCyPIiZA4JwwyOj+IhJ-KmzckHzCliJKgF92dlBIWEQUAFFwKABPYjIM2gZmNiVsTBa8fgwsXEJx9JAKABt-uxduwYFQEJ9WggAPr2MCXBQCZ6Qt5oF5fNL+P6AoT8M7wq4-DhcFxgChQVqsZDI17IXa7BBfMDIDzkNb0ZAAZQgYAI+MuE0qeAAdHBMpkBDC4ZcBMSuDx+HA8BcQAhBBtkAAWABMABofOh+AIQBrWgBCNkA-7IFTIVoAKmQ2uQ-E1wKElSAA\n    | (<T extends TData>(\n        previousData: T | undefined,\n      ) => NoInfer<TDataInitial> | NoInfer<TData> | undefined)\n}\n\n/**\n * Default options for `useQuery()`. Modifying this object will affect all the queries that don't override these\n */\nexport const USE_QUERY_DEFAULTS = {\n  staleTime: 1000 * 5, // 5 seconds\n  gcTime: (1000 * 60 * 5) as NonNullable<UseQueryOptions['gcTime']>, // 5 minutes\n  // avoid type narrowing to `true`\n  refetchOnWindowFocus: true as NonNullable<UseQueryOptions['refetchOnWindowFocus']>,\n  refetchOnReconnect: true as NonNullable<UseQueryOptions['refetchOnReconnect']>,\n  refetchOnMount: true as NonNullable<UseQueryOptions['refetchOnMount']>,\n  enabled: true as MaybeRefOrGetter<boolean>,\n} satisfies UseQueryOptionsGlobal\n\nexport type UseQueryOptionsWithDefaults<\n  TData = unknown,\n  TError = ErrorDefault,\n  TDataInitial extends TData | undefined = undefined,\n> = UseQueryOptions<TData, TError, TDataInitial> & typeof USE_QUERY_DEFAULTS\n\n/**\n * Global default options for `useQuery()`.\n * @internal\n */\nexport type UseQueryOptionsGlobalDefaults = UseQueryOptionsGlobal & typeof USE_QUERY_DEFAULTS\n\nexport const USE_QUERY_OPTIONS_KEY: InjectionKey<UseQueryOptionsGlobalDefaults>\n  = process.env.NODE_ENV !== 'production' ? Symbol('useQueryOptions') : Symbol()\n\n/**\n * Injects the global query options.\n *\n * @internal\n */\nexport const useQueryOptions = (): UseQueryOptionsGlobalDefaults =>\n  inject(USE_QUERY_OPTIONS_KEY, USE_QUERY_DEFAULTS)\n","import type { ErrorDefault } from './types-extension'\n\nexport function toCacheKey(key: undefined): undefined\nexport function toCacheKey(key: EntryKey): string\nexport function toCacheKey(key: EntryKey | undefined): string | undefined\n/**\n * Serializes the given {@link EntryKey | key} (query or mutation key) to a string.\n *\n * @param key - The key to serialize.\n *\n * @see {@link EntryKey}\n */\nexport function toCacheKey(key: EntryKey | undefined): string | undefined {\n  return (\n    key\n    && JSON.stringify(key, (_, val) =>\n      !val || typeof val !== 'object' || Array.isArray(val)\n        ? val\n        : Object.keys(val)\n            .sort()\n            .reduce((result, key) => {\n              result[key] = val[key]\n              return result\n            }, {} as any))\n  )\n}\n\n/**\n * Checks whether `subsetKey` is a subset of `fullsetKey` by matching partially objects and arrays.\n *\n * @param subsetKey - subset key to check\n * @param fullsetKey - fullset key to check against\n */\nexport function isSubsetOf(subsetKey: EntryKey, fullsetKey: EntryKey): boolean {\n  return subsetKey === fullsetKey\n    ? true\n    : typeof subsetKey !== typeof fullsetKey\n      ? false\n      : subsetKey && fullsetKey && typeof subsetKey === 'object' && typeof fullsetKey === 'object'\n        ? Object.keys(subsetKey).every((key) =>\n            isSubsetOf(\n              // NOTE: this or making them `any` in the function signature\n              subsetKey[key as unknown as number] as EntryKey,\n              fullsetKey[key as unknown as number] as EntryKey,\n            ),\n          )\n        : false\n}\n\n/**\n * Used for keys\n *\n * @internal\n */\nexport type JSONPrimitive = string | number | boolean | null\n\n/**\n * Used for keys\n *\n * @internal\n */\nexport type JSONValue = JSONPrimitive | JSONObject | JSONArray\n\n/**\n * Used for keys. Interface to avoid deep recursion.\n *\n * @internal\n */\nexport interface JSONObject {\n  readonly [key: string]: JSONValue | undefined\n}\n\n/**\n * Used for keys. Interface to avoid deep recursion.\n *\n * @internal\n */\nexport interface JSONArray extends Array<JSONValue> {}\n\n/**\n * Key used to identify a query or a mutation. Must be a JSON serializable\n * value. Type is unknwon to avoid deep type recursion.\n */\nexport type EntryKey = readonly JSONValue[]\n// export type EntryKey = readonly (unknown)[]\n\n/**\n * Internal symbol used to tag the data type of the entry key.\n *\n * @internal\n */\nexport const ENTRY_DATA_TAG = Symbol('Pinia Colada data tag')\n\n/**\n * Internal symbol used to tag the error type of the entry key.\n *\n * @internal\n */\nexport const ENTRY_ERROR_TAG = Symbol('Pinia Colada error tag')\n\n/**\n * Internal symbol used to tag the data initial type of the entry key.\n *\n * @internal\n */\nexport const ENTRY_DATA_INITIAL_TAG = Symbol('Pinia Colada data initial tag')\n\n/**\n * Same as {@link EntryKey} but with a data tag that allows inference of the data type.\n * Used by `defineQueryOptions()`.\n */\nexport type EntryKeyTagged<\n  TData,\n  TError = ErrorDefault,\n  TDataInitial extends TData | undefined = undefined,\n> = EntryKey & {\n  [ENTRY_DATA_TAG]: TData\n  [ENTRY_ERROR_TAG]: TError\n  [ENTRY_DATA_INITIAL_TAG]: TDataInitial\n}\n\n/**\n * Finds entries that partially match the given key. If no key is provided, all\n * entries are returned.\n *\n * @param map - The map to search in.\n * @param partialKey - The key to match against. If not provided, all entries are yield.\n *\n * @internal\n */\nexport function* find<T extends { key: EntryKey | undefined }>(\n  map: Map<string, T>,\n  partialKey?: EntryKey,\n) {\n  for (const entry of map.values()) {\n    if (!partialKey || (entry.key && isSubsetOf(partialKey, entry.key))) {\n      yield entry\n    }\n  }\n}\n","import { computed, getCurrentScope, onScopeDispose } from 'vue'\nimport type { MaybeRefOrGetter, Ref, ShallowRef } from 'vue'\n\n/**\n * Adds an event listener to Window that is automatically removed on scope dispose.\n */\nexport function useEventListener<E extends keyof WindowEventMap>(\n  target: Window,\n  event: E,\n  listener: (this: Window, ev: WindowEventMap[E]) => any,\n  options?: boolean | AddEventListenerOptions,\n): void\n\n/**\n * Adds an event listener to Document that is automatically removed on scope dispose.\n */\nexport function useEventListener<E extends keyof DocumentEventMap>(\n  target: Document,\n  event: E,\n  listener: (this: Document, ev: DocumentEventMap[E]) => any,\n  options?: boolean | AddEventListenerOptions,\n): void\n\nexport function useEventListener(\n  target: Document | Window | EventTarget,\n  event: string,\n  listener: (this: EventTarget, ev: Event) => any,\n  options?: boolean | AddEventListenerOptions,\n) {\n  target.addEventListener(event, listener, options)\n  if (getCurrentScope()) {\n    onScopeDispose(() => {\n      target.removeEventListener(event, listener)\n    })\n  }\n}\n\nexport const IS_CLIENT = typeof window !== 'undefined'\n\n/**\n * Type that represents a value that can be an array or a single value.\n *\n * @internal\n */\nexport type _MaybeArray<T> = T | T[]\n\n/**\n * Checks if a type is exactly `any`.\n *\n * @internal\n */\nexport type IsAny<T> = 0 extends 1 & T ? true : false\n\n/**\n * Checks if a type is exactly `unknown`. This is useful to determine if a type is\n *\n * @internal\n */\nexport type IsUnknown<T> = IsAny<T> extends true ? false : unknown extends T ? true : false\n\n/**\n * Type that represents a value that can be a function or a single value. Used\n * for `defineQuery()` and `defineMutation()`.\n *\n * @internal\n */\nexport type _MaybeFunction<T, Args extends any[] = []> = T | ((...args: Args) => T)\n\n/**\n * Transforms a value or a function that returns a value to a value.\n *\n * @param valFn either a value or a function that returns a value\n * @param args  arguments to pass to the function if `valFn` is a function\n */\nexport function toValueWithArgs<T, Args extends any[]>(\n  valFn: T | ((...args: Args) => T),\n  ...args: Args\n): T {\n  return typeof valFn === 'function' ? (valFn as (...args: Args) => T)(...args) : valFn\n}\n\n/**\n * Type that represents a value that can be a promise or a single value.\n *\n * @internal\n */\nexport type _Awaitable<T> = T | Promise<T>\n\n/**\n * Flattens an object type for readability.\n *\n * @internal\n */\nexport type _Simplify<T> = { [K in keyof T]: T[K] }\n\n/**\n * Converts a value to an array if necessary.\n *\n * @param value - value to convert\n */\nexport const toArray = <T>(value: _MaybeArray<T>): T[] => (Array.isArray(value) ? value : [value])\n\n/**\n * Valid primitives that can be stringified with `JSON.stringify`.\n *\n * @internal\n */\nexport type _JSONPrimitive = string | number | boolean | null | undefined\n\n/**\n * Utility type to represent a flat object that can be stringified with\n * `JSON.stringify` no matter the order of keys.\n *\n * @internal\n */\nexport interface _ObjectFlat {\n  [key: string]: _JSONPrimitive | Array<_JSONPrimitive>\n}\n\n/**\n * Valid values that can be stringified with `JSON.stringify`.\n *\n * @internal\n */\nexport type _JSONValue = _JSONPrimitive | _JSONValue[] | { [key: string]: _JSONValue }\n\n/**\n * Stringifies an object no matter the order of keys. This is used to create a\n * hash for a given object. It only works with flat objects. It can contain\n * arrays of primitives only. `undefined` values are skipped.\n *\n * @param obj - object to stringify\n */\nexport function stringifyFlatObject(obj: _ObjectFlat | _JSONPrimitive): string {\n  return obj && typeof obj === 'object' ? JSON.stringify(obj, Object.keys(obj).sort()) : String(obj)\n}\n\n/**\n * Merges two types when the second one can be null | undefined. Allows to safely use the returned type for { ...a,\n * ...undefined, ...null }\n * @internal\n */\nexport type _MergeObjects<Obj, MaybeNull> = MaybeNull extends undefined | null | void\n  ? Obj\n  : _Simplify<Obj & MaybeNull>\n\n/**\n * @internal\n */\nexport const noop = () => {}\n\n/**\n * Wraps a getter to be used as a ref. This is useful when you want to use a getter as a ref but you need to modify the\n * value.\n *\n * @internal\n * @param other - getter of the ref to compute\n * @returns a wrapper around a writable getter that can be used as a ref\n */\nexport const computedRef = <T>(other: () => Ref<T>): ShallowRef<T> =>\n  computed({\n    get: () => other().value,\n    set: (value) => (other().value = value),\n  })\n\n/**\n * Renames a property in an object type.\n */\nexport type _RenameProperty<T, Key extends keyof T, NewKey extends string> = {\n  [P in keyof T as P extends Key ? NewKey : P]: T[P]\n}\n\n/**\n * Type safe version of `Object.assign` that allows to set all properties of a reactive object at once. Used to set\n * {@link DataState} properties in a type safe way.\n */\nexport const setReactiveValue = Object.assign as <T>(value: T, ...args: T[]) => T\n\n/**\n * To avoid using `{}`\n * @internal\n */\nexport interface _EmptyObject {}\n\n/**\n * Dev only warning that is only shown once.\n */\nconst warnedMessages = new Set<string>()\n\n/**\n * Warns only once. This should only be used in dev\n *\n * @param message - Message to show\n * @param id - Unique id for the message, defaults to the message\n */\nexport function warnOnce(message: string, id: string = message) {\n  if (warnedMessages.has(id)) return\n  warnedMessages.add(id)\n  console.warn(`[@pinia/colada]: ${message}`)\n}\n\n/**\n * @internal\n */\nexport type _IsMaybeRefOrGetter<T> = [T] extends [MaybeRefOrGetter<infer U>]\n  ? MaybeRefOrGetter<U> extends T // must match the wrapper, not just any function\n    ? true\n    : false\n  : false\n\n/**\n * @internal\n */\nexport type _UnwrapMaybeRefOrGetter<T> = T extends MaybeRefOrGetter<infer U> ? U : T\n\n/**\n * Removes the `MaybeRefOrGetter` wrapper from all fields of an object.\n * @internal\n */\nexport type _RemoveMaybeRef<T> = {\n  [K in keyof T]: _IsMaybeRefOrGetter<NonNullable<T[K]>> extends true\n    ? _UnwrapMaybeRefOrGetter<T[K]>\n    : T[K]\n}\n","import type { ComputedRef, MaybeRefOrGetter, Ref, ShallowRef } from 'vue'\nimport {\n  computed,\n  getCurrentInstance,\n  getCurrentScope,\n  isRef,\n  onMounted,\n  onScopeDispose,\n  onServerPrefetch,\n  onUnmounted,\n  toValue,\n  watch,\n} from 'vue'\nimport { IS_CLIENT, useEventListener } from './utils'\nimport type { UseQueryEntry, UseQueryEntryExtensions } from './query-store'\nimport { currentDefineQueryEntry, isEntryUsingPlaceholderData, useQueryCache } from './query-store'\nimport { useQueryOptions } from './query-options'\nimport type { UseQueryOptions, UseQueryOptionsWithDefaults } from './query-options'\nimport type { ErrorDefault } from './types-extension'\nimport { currentDefineQueryEffect } from './define-query'\nimport type { DefineQueryOptions } from './define-query'\nimport type { AsyncStatus, DataState, DataStateStatus, DataState_Success } from './data-state'\n\n/**\n * Return type of `useQuery()`.\n */\nexport interface UseQueryReturn<\n  TData = unknown,\n  TError = ErrorDefault,\n  TDataInitial extends TData | undefined = undefined,\n> extends UseQueryEntryExtensions<TData, TError, TDataInitial> {\n  /**\n   * The state of the query. Contains its data, error, and status.\n   */\n  state: ComputedRef<DataState<TData, TError, TDataInitial>>\n\n  /**\n   * Status of the query. Becomes `'loading'` while the query is being fetched, is `'idle'` otherwise.\n   */\n  asyncStatus: ComputedRef<AsyncStatus>\n\n  /**\n   * The last successful data resolved by the query. Alias for `state.value.data`.\n   *\n   * @see {@link state}\n   */\n  data: ShallowRef<TData | TDataInitial>\n\n  /**\n   * The error rejected by the query. Alias for `state.value.error`.\n   *\n   * @see {@link state}\n   */\n  error: ShallowRef<TError | null>\n\n  /**\n   * The status of the query. Alias for `state.value.status`.\n   *\n   * @see {@link state}\n   * @see {@link DataStateStatus}\n   */\n  status: ShallowRef<DataStateStatus>\n\n  /**\n   * Returns whether the request is still pending its first call. Alias for `status.value === 'pending'`\n   */\n  isPending: ComputedRef<boolean>\n\n  /**\n   * Returns whether the `data` is the `placeholderData`.\n   */\n  isPlaceholderData: ComputedRef<boolean>\n\n  /**\n   * Returns whether the request is currently fetching data. Alias for `asyncStatus.value === 'loading'`\n   */\n  isLoading: ShallowRef<boolean>\n\n  /**\n   * Ensures the current data is fresh. If the data is stale, refetch, if not return as is.\n   * @param throwOnError - whether to throw an error if the refresh fails. Defaults to `false`\n   * @returns a promise that resolves when the refresh is done\n   */\n  refresh: (throwOnError?: boolean) => Promise<DataState<TData, TError, TDataInitial>>\n\n  /**\n   * Ignores fresh data and triggers a new fetch\n   * @param throwOnError - whether to throw an error if the fetch fails. Defaults to `false`\n   * @returns a promise that resolves when the fetch is done\n   */\n  refetch: (throwOnError?: boolean) => Promise<DataState<TData, TError, TDataInitial>>\n}\n\n/**\n * Ensures and return a shared query state based on the `key` option.\n *\n * @param options - The options of the query\n *\n * @example\n * ```ts\n * const { state } = useQuery({\n *   key: ['documents'],\n *   query: () => getDocuments(),\n * })\n * ```\n */\nexport function useQuery<\n  TData,\n  TError = ErrorDefault,\n  TDataInitial extends TData | undefined = undefined,\n>(\n  options:\n    | UseQueryOptions<TData, TError, TDataInitial>\n    | (() => DefineQueryOptions<TData, TError, TDataInitial>),\n): UseQueryReturn<TData, TError, TDataInitial>\n\n/**\n * `useQuery` for dynamic typed query keys. Requires options defined with\n * {@link defineQueryOptions}.\n *\n * @param setupOptions - options defined with {@link defineQueryOptions}\n * @param paramsGetter - a getter or ref that returns the parameters for the `setupOptions`\n *\n * @example\n * ```ts\n * import { defineQueryOptions, useQuery } from '@pinia/colada'\n *\n * const documentDetailsQuery = defineQueryOptions((id: number ) => ({\n *   key: ['documents', id],\n *   query: () => fetchDocument(id),\n * }))\n *\n * useQuery(documentDetailsQuery, 4)\n * useQuery(documentDetailsQuery, () => route.params.id)\n * useQuery(documentDetailsQuery, () => props.id)\n * ```\n */\nexport function useQuery<Params, TData, TError, TDataInitial extends TData | undefined>(\n  setupOptions: (params: Params) => DefineQueryOptions<TData, TError, TDataInitial>,\n  paramsGetter: MaybeRefOrGetter<NoInfer<Params>>,\n): UseQueryReturn<TData, TError, TDataInitial>\n\n/**\n * Ensures and return a shared query state based on the `key` option.\n *\n * @param _options - The options of the query\n * @param paramsGetter - a getter or ref that returns the parameters for the `_options`\n */\nexport function useQuery<\n  TData,\n  TError = ErrorDefault,\n  TDataInitial extends TData | undefined = undefined,\n>(\n  // NOTE: this version has better type inference but still imperfect\n  ...[_options, paramsGetter]:\n    | [\n        | UseQueryOptions<TData, TError, TDataInitial>\n        | (() => DefineQueryOptions<TData, TError, TDataInitial>),\n      ]\n    | [\n        (params: unknown) => DefineQueryOptions<TData, TError, TDataInitial>,\n        paramsGetter?: MaybeRefOrGetter<unknown>,\n      ]\n  // _options:\n  //   | UseQueryOptions<TData, TError, TDataInitial>\n  //   | (() => DefineQueryOptions<TData, TError, TDataInitial>)\n  //   | ((params: unknown) => DefineQueryOptions<TData, TError, TDataInitial>),\n  // paramsGetter?: MaybeRefOrGetter<unknown>,\n): UseQueryReturn<TData, TError, TDataInitial> {\n  if (paramsGetter != null) {\n    return useQuery(() =>\n      // NOTE: we manually type cast here because TS cannot infer correctly in overloads\n      (_options as (params: unknown) => DefineQueryOptions<TData, TError, TDataInitial>)(\n        toValue(paramsGetter),\n      ),\n    )\n  }\n  const queryCache = useQueryCache()\n  const optionDefaults = useQueryOptions()\n  const hasCurrentInstance = getCurrentInstance()\n  // this is the effect created by defineQuery in ensureDefinedQuery\n  // it shouldn't be tracked by the query cache otherwise it would never cleanup\n  const defineQueryEffect = currentDefineQueryEntry?.[2]\n  const currentEffect = currentDefineQueryEffect || getCurrentScope()\n  const isPaused = currentDefineQueryEntry?.[3]\n\n  const options = computed(\n    () =>\n      ({\n        ...optionDefaults,\n        ...toValue(\n          // NOTE: we manually type cast here because TS cannot infer correctly in overloads\n          _options as\n            | UseQueryOptions<TData, TError, TDataInitial>\n            | (() => DefineQueryOptions<TData, TError, TDataInitial>),\n        ),\n      }) satisfies UseQueryOptionsWithDefaults<TData, TError, TDataInitial>,\n  )\n  const enabled = (): boolean => toValue(options.value.enabled)\n\n  // NOTE: here we used to check if the same key was previously called with a different query\n  // but it ended up creating too many false positives and was removed. We could add it back\n  // to at least warn against the cases shown in https://pinia-colada.esm.dev/guide/reusable-queries.html\n\n  // This plain variable is not reactive and allows us to use the currentEntry\n  // without triggering watchers and creating entries. It is used during\n  // unmounting and mounting\n  let lastEntry: UseQueryEntry<TData, TError, TDataInitial>\n  const entry = computed(() =>\n    // NOTE: there should be a `paused` property on the effect later on\n    // if the effect is paused, we don't want to compute the entry because its key\n    // might be referencing undefined values\n    // https://github.com/posva/pinia-colada/issues/227\n    // NOTE: _isPaused isn't reactive which meant that reentering a component\n    // would never recompute the entry, so _isPaused was replaced\n    // this makes the computed depend on nothing initially, but the `watch` on the entry\n    // with immediate: true will trigger it again\n    // https://github.com/posva/pinia-colada/issues/290\n    isPaused?.value // && currentEffect?._isPaused\n      ? lastEntry!\n      : (lastEntry = queryCache.ensure<TData, TError, TDataInitial>(options.value, lastEntry)),\n  )\n  // we compute the entry here and reuse this across\n  lastEntry = entry.value\n\n  // adapter that returns the entry state\n  const errorCatcher = () => entry.value.state.value\n  const refresh = (throwOnError?: boolean) =>\n    queryCache.refresh(entry.value, options.value).catch(\n      // true is not allowed but it works per spec as only callable onRejected are used\n      // https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-performpromisethen\n      // In other words `Promise.rejects('ok').catch(true)` still rejects\n      // anything other than `true` falls back to the `errorCatcher`\n      (throwOnError as false | undefined) || errorCatcher,\n    )\n  const refetch = (throwOnError?: boolean) =>\n    queryCache.fetch(entry.value, options.value).catch(\n      // same as above\n      (throwOnError as false | undefined) || errorCatcher,\n    )\n  const isPlaceholderData = computed(() => isEntryUsingPlaceholderData(entry.value))\n  const state = computed<DataState<TData, TError, TDataInitial>>(() =>\n    isPlaceholderData.value\n      ? ({\n          status: 'success',\n          data: entry.value.placeholderData!,\n          error: null,\n        } satisfies DataState_Success<TData, TDataInitial>)\n      : entry.value.state.value,\n  )\n\n  // TODO: find a way to allow a custom implementation for the returned value\n  const extensions = {} as Record<string, any>\n  for (const key in lastEntry.ext) {\n    extensions[key] = computed<unknown>({\n      get: () =>\n        toValue<unknown>(entry.value.ext[key as keyof UseQueryEntryExtensions<TData, TError>]),\n      set(value) {\n        const target = entry.value.ext[key as keyof UseQueryEntryExtensions<TData, TError>]\n        if (isRef(target)) {\n          ;(target as Ref | ShallowRef).value = value\n        } else {\n          ;(entry.value.ext[key as keyof UseQueryEntryExtensions<TData, TError>] as unknown) = value\n        }\n      },\n    })\n  }\n\n  const queryReturn = {\n    ...(extensions as UseQueryEntryExtensions<TData, TError, TDataInitial>),\n    state,\n\n    status: computed(() => state.value.status),\n    data: computed(() => state.value.data),\n    error: computed(() => entry.value.state.value.error),\n    asyncStatus: computed(() => entry.value.asyncStatus.value),\n\n    isPlaceholderData,\n    isPending: computed(() => state.value.status === 'pending'),\n    isLoading: computed(() => entry.value.asyncStatus.value === 'loading'),\n\n    refresh,\n    refetch,\n  } satisfies UseQueryReturn<TData, TError, TDataInitial>\n\n  if (hasCurrentInstance) {\n    // only happens on server, app awaits this\n    onServerPrefetch(async () => {\n      if (toValue(enabled)) await refresh(true)\n    })\n  }\n\n  // should we be watching entry\n  // NOTE: this avoids fetching initially during SSR but it could be refactored to only use the watcher\n  let isActive = false\n  if (hasCurrentInstance) {\n    onMounted(() => {\n      isActive = true\n      queryCache.track(lastEntry, hasCurrentInstance)\n    })\n    onUnmounted(() => {\n      // remove instance from Set of refs\n      queryCache.untrack(lastEntry, hasCurrentInstance)\n    })\n  } else {\n    isActive = true\n    if (currentEffect !== defineQueryEffect) {\n      queryCache.track(lastEntry, currentEffect)\n      onScopeDispose(() => {\n        queryCache.untrack(lastEntry, currentEffect)\n      })\n    }\n  }\n\n  watch(\n    entry,\n    (entry, previousEntry) => {\n      if (!isActive) return\n      if (previousEntry) {\n        queryCache.untrack(previousEntry, hasCurrentInstance)\n        queryCache.untrack(previousEntry, currentEffect)\n      }\n      // track the current effect and component\n      queryCache.track(entry, hasCurrentInstance)\n      if (currentEffect !== defineQueryEffect) {\n        queryCache.track(entry, currentEffect)\n      }\n\n      // TODO: does this trigger after unmount?\n      if (toValue(enabled)) refresh()\n    },\n    {\n      immediate: true,\n    },\n  )\n\n  // avoid adding a watcher if enabled cannot change\n  if (typeof enabled !== 'boolean') {\n    watch(enabled, (newEnabled) => {\n      // no need to check for the previous value since the watcher will only trigger if the value changed\n      if (newEnabled) refresh()\n    })\n  }\n\n  // only happens on client\n  // we could also call fetch instead but forcing a refresh is more interesting\n  if (hasCurrentInstance) {\n    onMounted(() => {\n      if (enabled()) {\n        const refetchControl = toValue(options.value.refetchOnMount)\n        if (refetchControl === 'always') {\n          refetch()\n        } else if (\n          refetchControl\n          // always refetch if the query is not enabled\n          || queryReturn.status.value === 'pending'\n        ) {\n          refresh()\n        }\n      }\n    })\n  }\n  // TODO: we could save the time it was fetched to avoid fetching again. This is useful to not refetch during SSR app but do refetch in SSG apps if the data is stale. Careful with timers and timezones\n\n  if (IS_CLIENT) {\n    useEventListener(document, 'visibilitychange', () => {\n      const refetchControl = toValue(options.value.refetchOnWindowFocus)\n      if (document.visibilityState === 'visible' && toValue(enabled)) {\n        if (refetchControl === 'always') {\n          refetch()\n        } else if (refetchControl) {\n          refresh()\n        }\n      }\n    })\n\n    useEventListener(window, 'online', () => {\n      if (toValue(enabled)) {\n        const refetchControl = toValue(options.value.refetchOnReconnect)\n        if (refetchControl === 'always') {\n          refetch()\n        } else if (refetchControl) {\n          refresh()\n        }\n      }\n    })\n  }\n\n  return queryReturn\n}\n","import type { ComputedRef, MaybeRefOrGetter } from 'vue'\nimport { computed, toValue } from 'vue'\nimport { useQueryCache } from './query-store'\nimport type { UseQueryReturn } from './use-query'\nimport type { EntryKey, EntryKeyTagged } from './entry-keys'\nimport type { AsyncStatus, DataState, DataStateStatus } from './data-state'\nimport type { ErrorDefault } from './types-extension'\nimport type { DefineQueryOptions } from './define-query'\nimport type { defineQueryOptions } from './define-query-options'\n\n/**\n * Return type for the {@link useQueryState} composable.\n *\n * @see {@link useQueryState}\n */\nexport interface UseQueryStateReturn<\n  TData = unknown,\n  TError = ErrorDefault,\n  TDataInitial extends TData | undefined = undefined,\n> {\n  /**\n   * `state` of the query entry.\n   *\n   * @see {@link UseQueryReturn#state}\n   */\n  state: ComputedRef<DataState<TData, TError, TDataInitial> | undefined>\n\n  /**\n   * `data` of the query entry.\n   *\n   * @see {@link UseQueryReturn#data}\n   */\n  data: ComputedRef<TData | TDataInitial | undefined>\n\n  /**\n   * `error` of the query entry.\n   *\n   * @see {@link UseQueryReturn#error}\n   */\n  error: ComputedRef<TError | null | undefined>\n\n  /**\n   * `status` of the query entry.\n   *\n   * @see {@link DataStateStatus}\n   * @see {@link UseQueryReturn#status}\n   */\n  status: ComputedRef<DataStateStatus | undefined>\n\n  /**\n   * `asyncStatus` of the query entry.\n   *\n   * @see {@link AsyncStatus}\n   * @see {@link UseQueryReturn#asyncStatus}\n   */\n  asyncStatus: ComputedRef<AsyncStatus | undefined>\n\n  /**\n   * Is the query entry currently pending or non existent.\n   */\n  isPending: ComputedRef<boolean>\n}\n\n/**\n * Reactive access to the state of a query entry without fetching it.\n *\n * @param key - tagged key of the query entry to access\n */\nexport function useQueryState<\n  TData,\n  TError = ErrorDefault,\n  TDataInitial extends TData | undefined = undefined,\n>(\n  key: MaybeRefOrGetter<EntryKeyTagged<TData, TError, TDataInitial>>,\n): UseQueryStateReturn<TData, TError, TDataInitial>\n\n/**\n * Reactive access to the state of a query entry without fetching it.\n *\n * @param setupOptions - function that returns the query options based on the provided params\n * @param paramsGetter - getter for the parameters used to generate the query key\n *\n * @see {@link DefineQueryOptions}\n * @see {@link defineQueryOptions}\n */\nexport function useQueryState<Params, TData, TError, TDataInitial extends TData | undefined>(\n  setupOptions: (params: Params) => DefineQueryOptions<TData, TError, TDataInitial>,\n  paramsGetter: MaybeRefOrGetter<NoInfer<Params>>,\n): UseQueryStateReturn<TData, TError, TDataInitial>\n\n/**\n * Reactive access to the state of a query entry without fetching it.\n *\n * @param key - key of the query entry to access\n */\nexport function useQueryState<\n  TData,\n  TError = ErrorDefault,\n  TDataInitial extends TData | undefined = undefined,\n>(key: MaybeRefOrGetter<EntryKey>): UseQueryStateReturn<TData, TError, TDataInitial>\n\nexport function useQueryState<\n  TData,\n  TError = ErrorDefault,\n  TDataInitial extends TData | undefined = undefined,\n>(\n  // NOTE: this version has better type inference but still imperfect\n  ...[_keyOrSetup, paramsGetter]:\n    | [key: MaybeRefOrGetter<EntryKeyTagged<TData, TError, TDataInitial> | EntryKey>]\n    | [\n        (params: unknown) => DefineQueryOptions<TData, TError, TDataInitial>,\n        paramsGetter?: MaybeRefOrGetter<unknown>,\n      ]\n): UseQueryStateReturn<TData, TError, TDataInitial> {\n  const queryCache = useQueryCache()\n\n  const key = paramsGetter\n    ? computed(\n        () =>\n          // NOTE: we manually type cast here because TS cannot infer correctly in overloads\n          (_keyOrSetup as (params: unknown) => DefineQueryOptions<TData, TError, TDataInitial>)(\n            toValue(paramsGetter),\n          ).key as EntryKeyTagged<TData, TError, TDataInitial>,\n      )\n    : (_keyOrSetup as EntryKeyTagged<TData, TError, TDataInitial>)\n\n  const entry = computed(() => queryCache.get(toValue(key)))\n\n  const state = computed(() => entry.value?.state.value)\n  const data = computed(() => state.value?.data)\n  const error = computed(() => state.value?.error)\n  const status = computed(() => state.value?.status)\n  const asyncStatus = computed(() => entry.value?.asyncStatus.value)\n  const isPending = computed(() => !state.value || state.value.status === 'pending')\n\n  return {\n    state,\n    data,\n    error,\n    status,\n    asyncStatus,\n    isPending,\n  }\n}\n","import { toValue } from 'vue'\nimport type { UseQueryFnContext, UseQueryOptions } from './query-options'\nimport { useQuery } from './use-query'\nimport type { UseQueryReturn } from './use-query'\nimport type { ErrorDefault } from './types-extension'\n\n/**\n * Options for {@link useInfiniteQuery}.\n *\n * @experimental See https://github.com/posva/pinia-colada/issues/178\n */\nexport interface UseInfiniteQueryOptions<\n  TData,\n  TError,\n  TDataInitial extends TData | undefined = TData | undefined,\n  TPages = unknown,\n> extends Omit<\n    UseQueryOptions<TData, TError, TDataInitial>,\n    'query' | 'initialData' | 'placeholderData' | 'key'\n  > {\n  key: UseQueryOptions<TPages, TError, TPages>['key']\n  /**\n   * The function that will be called to fetch the data. It **must** be async.\n   */\n  query: (pages: NoInfer<TPages>, context: UseQueryFnContext) => Promise<TData>\n  initialPage: TPages | (() => TPages)\n  merge: (result: NoInfer<TPages>, current: NoInfer<TData>) => NoInfer<TPages>\n}\n\nexport interface UseInfiniteQueryReturn<TPage = unknown, TError = ErrorDefault>\n  extends Omit<UseQueryReturn<TPage, TError, TPage>, 'refetch' | 'refresh'> {\n  loadMore: () => Promise<unknown>\n}\n\n/**\n * Store and merge paginated data into a single cache entry. Allows to handle\n * infinite scrolling. This is an **experimental** API and is subject to\n * change.\n *\n * @param options - Options to configure the infinite query.\n *\n * @experimental See https://github.com/posva/pinia-colada/issues/178\n */\nexport function useInfiniteQuery<TData, TError = ErrorDefault, TPage = unknown>(\n  options: UseInfiniteQueryOptions<TData, TError, TData | undefined, TPage>,\n): UseInfiniteQueryReturn<TPage, TError> {\n  let pages: TPage = toValue(options.initialPage)\n\n  const { refetch, refresh, ...query } = useQuery<TPage, TError, TPage>({\n    ...options,\n    initialData: () => pages,\n    // since we hijack the query function and augment the data, we cannot refetch the data\n    // like usual\n    staleTime: Infinity,\n    async query(context) {\n      const data: TData = await options.query(pages, context)\n      return (pages = options.merge(pages, data))\n    },\n  })\n\n  return {\n    ...query,\n    loadMore: () => refetch(),\n  }\n}\n","import type { ShallowRef } from 'vue'\nimport type { AsyncStatus, DataState } from './data-state'\nimport { defineStore, skipHydrate } from 'pinia'\nimport { customRef, getCurrentScope, shallowRef } from 'vue'\nimport { find, toCacheKey } from './entry-keys'\nimport type { EntryFilter } from './entry-filter'\nimport type { _EmptyObject } from './utils'\nimport { noop, toValueWithArgs } from './utils'\nimport type { _ReduceContext } from './use-mutation'\nimport { useMutationOptions } from './mutation-options'\nimport type { UseMutationOptions } from './mutation-options'\nimport type { EntryKey } from './entry-keys'\n\n/**\n * A mutation entry in the cache.\n */\nexport interface UseMutationEntry<\n  TData = unknown,\n  TVars = unknown,\n  TError = unknown,\n  TContext extends Record<any, any> = _EmptyObject,\n> {\n  /**\n   * Unique id of the mutation entry. Empty string if the entry is not yet in the cache.\n   */\n  id: string\n\n  /**\n   * The state of the mutation. Contains the data, error and status.\n   */\n  state: ShallowRef<DataState<TData, TError>>\n\n  /**\n   * The async status of the mutation.\n   */\n  asyncStatus: ShallowRef<AsyncStatus>\n\n  /**\n   * When was this data fetched the last time in ms\n   */\n  when: number\n\n  /**\n   * The serialized key associated with this mutation entry.\n   */\n  key: EntryKey | undefined\n\n  /**\n   * Seriaized version of the key. Used to retrieve the entry from the cache.\n   * Can be `undefined` if the entry has no key.\n   */\n  keyHash: string | undefined\n\n  /**\n   * The variables used to call the mutation.\n   */\n  vars: TVars | undefined\n\n  /**\n   * Options used to create the mutation.\n   */\n  options: UseMutationOptions<TData, TVars, TError, TContext>\n\n  /**\n   * Timeout id that scheduled a garbage collection. It is set here to clear it when the entry is used by a different component.\n   */\n  gcTimeout: ReturnType<typeof setTimeout> | undefined\n}\n\n/**\n * Filter to get entries from the mutation cache.\n */\nexport type UseMutationEntryFilter = EntryFilter<UseMutationEntry>\n\nexport const MUTATION_STORE_ID = '_pc_mutation'\n\n/**\n * Composable to get the cache of the mutations. As any other composable, it\n * can be used inside the `setup` function of a component, within another\n * composable, or in injectable contexts like stores and navigation guards.\n */\nexport const useMutationCache = /* @__PURE__ */ defineStore(MUTATION_STORE_ID, ({ action }) => {\n  // We have two versions of the cache, one that track changes and another that doesn't so the actions can be used\n  // inside computed properties\n  // We have two versions of the cache, one that track changes and another that doesn't so the actions can be used\n  // inside computed properties\n  const cachesRaw = new Map<string, UseMutationEntry<unknown, any, unknown, any>>()\n  let triggerCache!: () => void\n  const caches = skipHydrate(\n    customRef(\n      (track, trigger) =>\n        (triggerCache = trigger) && {\n          // eslint-disable-next-line no-sequences\n          get: () => (track(), cachesRaw),\n          set:\n            process.env.NODE_ENV !== 'production'\n              ? () => {\n                  console.error(\n                    `[@pinia/colada]: The mutation cache instance cannot be set directly, it must be modified. This will fail in production.`,\n                  )\n                }\n              : noop,\n        },\n    ),\n  )\n\n  // this allows use to attach reactive effects to the scope later on\n  const scope = getCurrentScope()!\n\n  const globalOptions = useMutationOptions()\n  const defineMutationMap = new WeakMap<() => unknown, unknown>()\n\n  let nextMutationId = 0\n  const generateMutationId = () => `$${nextMutationId++}`\n\n  /**\n   * Creates a mutation entry and its state without adding it to the cache.\n   * This allows for the state to exist in `useMutation()` before the mutation\n   * is actually called. The mutation must be _ensured_ with {@link ensure}\n   * before being called.\n   *\n   * @param options - options to create the mutation\n   */\n  const create = action(\n    <\n      TData = unknown,\n      TVars = unknown,\n      TError = unknown,\n      TContext extends Record<any, any> = _EmptyObject,\n    >(\n      options: UseMutationOptions<TData, TVars, TError, TContext>,\n      key?: EntryKey | undefined,\n      vars?: TVars,\n    ): UseMutationEntry<TData, TVars, TError, TContext> =>\n      scope.run(\n        () =>\n          ({\n            id: '', // not a real id yet, indicates that the entry is not in the cache\n            state: shallowRef<DataState<TData, TError>>({\n              status: 'pending',\n              data: undefined,\n              error: null,\n            }),\n            gcTimeout: undefined,\n            asyncStatus: shallowRef<AsyncStatus>('idle'),\n            when: 0,\n            vars,\n            key,\n            keyHash: toCacheKey(key),\n            options,\n          }) satisfies UseMutationEntry<TData, TVars, TError, TContext>,\n      )!,\n  )\n\n  /**\n   * Ensures a mutation entry in the cache by assigning it an `id` and a `key` based on `vars`. Usually, a mutation is ensured twice\n   *\n   * @param entry - entry to ensure\n   * @param vars - variables to call the mutation with\n   */\n  function ensure<\n    TData = unknown,\n    TVars = unknown,\n    TError = unknown,\n    TContext extends Record<any, any> = _EmptyObject,\n  >(\n    entry: UseMutationEntry<TData, TVars, TError, TContext>,\n    vars: NoInfer<TVars>,\n  ): UseMutationEntry<TData, TVars, TError, TContext> {\n    const options = entry.options\n    const id = generateMutationId()\n    const key: EntryKey = [...toValueWithArgs(options.key || [], vars), id]\n    const keyHash = toCacheKey(key)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const badKey = key\n        ?.slice(0, -1) // the last part is the id\n        .find(\n          (k) =>\n            typeof k === 'string' && k.startsWith('$') && String(Number(k.slice(1))) === k.slice(1),\n        )\n      if (badKey) {\n        console.warn(\n          `[@pinia/colada] A mutation entry was created with a reserved key part \"${badKey}\". Do not name keys with \"$<number>\" as these are reserved in mutations.`,\n        )\n      }\n    }\n\n    entry = entry.id ? (untrack(entry), create(options, key, vars)) : entry\n    entry.id = id\n    entry.key = key\n    entry.keyHash = keyHash\n    entry.vars = vars\n\n    // store the entry with a generated key\n    cachesRaw.set(keyHash, entry as unknown as UseMutationEntry)\n    triggerCache()\n\n    return entry\n  }\n\n  /**\n   * Ensures a query created with {@link defineMutation} is present in the cache. If it's not, it creates a new one.\n   * @param fn - function that defines the query\n   */\n  const ensureDefinedMutation = action(<T>(fn: () => T) => {\n    let defineMutationResult = defineMutationMap.get(fn)\n    if (!defineMutationResult) {\n      defineMutationMap.set(fn, (defineMutationResult = scope.run(fn)))\n    }\n\n    return defineMutationResult\n  })\n\n  /**\n   * Sets the state of a query entry in the cache and updates the\n   * {@link UseQueryEntry['pending']['when'] | `when` property}. This action is\n   * called every time the cache state changes and can be used by plugins to\n   * detect changes.\n   *\n   * @param entry - the entry of the query to set the state\n   * @param state - the new state of the entry\n   */\n  const setEntryState = action(\n    <\n      TData = unknown,\n      TVars = unknown,\n      TError = unknown,\n      TContext extends Record<any, any> = _EmptyObject,\n    >(\n      entry: UseMutationEntry<TData, TVars, TError, TContext>,\n      // NOTE: NoInfer ensures correct inference of TData and TError\n      state: DataState<NoInfer<TData>, NoInfer<TError>>,\n    ) => {\n      entry.state.value = state\n      entry.when = Date.now()\n    },\n  )\n\n  /**\n   * Removes a query entry from the cache if it has a key. If it doesn't then it does nothing.\n   *\n   * @param entry - the entry of the query to remove\n   */\n  const remove = action(\n    <\n      TData = unknown,\n      TVars = unknown,\n      TError = unknown,\n      TContext extends Record<any, any> = _EmptyObject,\n    >(\n      entry: UseMutationEntry<TData, TVars, TError, TContext>,\n    ) => {\n      if (entry.keyHash) {\n        cachesRaw.delete(entry.keyHash)\n        triggerCache()\n      }\n    },\n  )\n\n  /**\n   * Returns all the entries in the cache that match the filters.\n   *\n   * @param filters - filters to apply to the entries\n   */\n  const getEntries = action((filters: UseMutationEntryFilter = {}): UseMutationEntry[] => {\n    return filters.exact\n      ? filters.key\n        ? [caches.value.get(toCacheKey(filters.key))].filter((v) => !!v)\n        : [] // no key, no exact entry\n      : [...find(caches.value, filters.key)].filter(\n          (entry) =>\n            (filters.status == null || entry.state.value.status === filters.status)\n            && (!filters.predicate || filters.predicate(entry)),\n        )\n  })\n\n  /**\n   * Untracks an effect or component that uses a mutation.\n   *\n   * @param entry - the entry of the mutation\n   * @param effect - the effect or component to untrack\n   *\n   * @see {@link track}\n   */\n  const untrack = action(\n    <\n      TData = unknown,\n      TVars = unknown,\n      TError = unknown,\n      TContext extends Record<any, any> = _EmptyObject,\n    >(\n      entry: UseMutationEntry<TData, TVars, TError, TContext>,\n    ) => {\n      // schedule a garbage collection if the entry is not active\n      if (entry.gcTimeout) return\n\n      // avoid setting a timeout with false, Infinity or NaN\n      if ((Number.isFinite as (val: unknown) => val is number)(entry.options.gcTime)) {\n        entry.gcTimeout = setTimeout(() => {\n          remove(entry)\n        }, entry.options.gcTime)\n      }\n    },\n  )\n\n  /**\n   * Mutate a previously ensured mutation entry.\n   *\n   * @param entry - the entry to mutate\n   */\n  async function mutate<\n    TData = unknown,\n    TVars = unknown,\n    TError = unknown,\n    TContext extends Record<any, any> = _EmptyObject,\n  >(entry: UseMutationEntry<TData, TVars, TError, TContext>): Promise<TData> {\n    // the vars is set when the entry is ensured, we warn against it below\n    const { vars, options } = entry as typeof entry & { vars: TVars }\n\n    // DEV warnings\n    if (process.env.NODE_ENV !== 'production') {\n      const key = entry.key?.join('/')\n      const keyMessage = key ? `with key \"${key}\"` : 'without a key'\n      if (!entry.id) {\n        console.error(\n          `[@pinia/colada] A mutation entry ${keyMessage} was mutated before being ensured. If you are manually calling the \"mutationCache.mutate()\", you should always ensure the entry first If not, this is probably a bug. Please, open an issue on GitHub with a boiled down reproduction.`,\n        )\n      }\n      if (\n        // the entry has already an ongoing request\n        entry.state.value.status !== 'pending'\n        || entry.asyncStatus.value === 'loading'\n      ) {\n        console.error(\n          `[@pinia/colada] A mutation entry ${keyMessage} was reused. If you are manually calling the \"mutationCache.mutate()\", you should always ensure the entry first: \"mutationCache.mutate(mutationCache.ensure(entry, vars))\". If not this is probably a bug. Please, open an issue on GitHub with a boiled down reproduction.`,\n        )\n      }\n    }\n\n    entry.asyncStatus.value = 'loading'\n\n    // TODO: AbortSignal that is aborted when the mutation is called again so we can throw in pending\n    let currentData: TData | undefined\n    let currentError: TError | undefined\n    type OnMutateContext = Parameters<\n      Required<UseMutationOptions<TData, TVars, TError, TContext>>['onMutate']\n    >['1']\n    type OnSuccessContext = Parameters<\n      Required<UseMutationOptions<TData, TVars, TError, TContext>>['onSuccess']\n    >['2']\n    type OnErrorContext = Parameters<\n      Required<UseMutationOptions<TData, TVars, TError, TContext>>['onError']\n    >['2']\n\n    let context: OnMutateContext | OnErrorContext | OnSuccessContext = {}\n\n    try {\n      const globalOnMutateContext = globalOptions.onMutate?.(vars)\n\n      context\n        = (globalOnMutateContext instanceof Promise\n          ? await globalOnMutateContext\n          : globalOnMutateContext) || {}\n\n      const onMutateContext = (await options.onMutate?.(\n        vars,\n        context,\n        // NOTE: the cast makes it easier to write without extra code. It's safe because { ...null, ...undefined } works and TContext must be a Record<any, any>\n      )) as _ReduceContext<TContext>\n\n      // we set the context here so it can be used by other hooks\n      context = {\n        ...context,\n        ...onMutateContext,\n        // NOTE: needed for onSuccess cast\n      } satisfies OnSuccessContext\n\n      const newData = (currentData = await options.mutation(vars, context as OnSuccessContext))\n\n      await globalOptions.onSuccess?.(newData, vars, context as OnSuccessContext)\n      await options.onSuccess?.(\n        newData,\n        vars,\n        // NOTE: cast is safe because of the satisfies above\n        // using a spread also works\n        context as OnSuccessContext,\n      )\n\n      setEntryState(entry, {\n        status: 'success',\n        data: newData,\n        error: null,\n      })\n    } catch (newError: unknown) {\n      currentError = newError as TError\n      await globalOptions.onError?.(currentError, vars, context)\n      await options.onError?.(currentError, vars, context)\n      setEntryState(entry, {\n        status: 'error',\n        data: entry.state.value.data,\n        error: currentError,\n      })\n      throw newError\n    } finally {\n      // TODO: should we catch and log it?\n      await globalOptions.onSettled?.(currentData, currentError, vars, context)\n      await options.onSettled?.(currentData, currentError, vars, context)\n      entry.asyncStatus.value = 'idle'\n    }\n\n    return currentData\n  }\n\n  return {\n    caches,\n\n    create,\n    ensure,\n    ensureDefinedMutation,\n    mutate,\n    remove,\n\n    setEntryState,\n    getEntries,\n    untrack,\n  }\n})\n","import { inject } from 'vue'\nimport type { InjectionKey } from 'vue'\nimport type { ErrorDefault } from './types-extension'\nimport type { _ReduceContext, _MutationKey, UseMutationGlobalContext } from './use-mutation'\nimport type { _EmptyObject, _Awaitable } from './utils'\n\n/**\n * Options for mutations that can be globally overridden.\n */\nexport interface UseMutationOptionsGlobal {\n  /**\n   * Runs before a mutation is executed. It can return a value that will be\n   * passed to `mutation`, `onSuccess`, `onError` and `onSettled`. If it\n   * returns a promise, it will be awaited before running `mutation`.\n   */\n  onMutate?: (\n    /**\n     * The variables passed to the mutation.\n     */\n    vars: unknown,\n  ) => _Awaitable<UseMutationGlobalContext | undefined | void | null>\n\n  /**\n   * Runs when a mutation is successful.\n   */\n  onSuccess?: (\n    /**\n     * The result of the mutation.\n     */\n    data: unknown,\n    /**\n     * The variables passed to the mutation.\n     */\n    vars: unknown,\n    /**\n     * The merged context from `onMutate` and the global context.\n     */\n    context: UseMutationGlobalContext,\n  ) => unknown\n\n  /**\n   * Runs when a mutation encounters an error.\n   */\n  onError?: (\n    /**\n     * The error thrown by the mutation.\n     */\n    error: unknown,\n    /**\n     * The variables passed to the mutation.\n     */\n    vars: unknown,\n    /**\n     * The merged context from `onMutate` and the global context. Properties returned by `onMutate` can be `undefined`\n     * if `onMutate` throws.\n     */\n    context:\n      | Partial<Record<keyof UseMutationGlobalContext, never>>\n      // this is the success case where everything is defined\n      // undefined if global onMutate throws\n      | UseMutationGlobalContext,\n  ) => unknown\n\n  /**\n   * Runs after the mutation is settled, regardless of the result.\n   */\n  onSettled?: (\n    /**\n     * The result of the mutation. `undefined` when a mutation failed.\n     */\n    data: unknown | undefined,\n    /**\n     * The error thrown by the mutation. `undefined` if the mutation was successful.\n     */\n    error: unknown | undefined,\n    /**\n     * The variables passed to the mutation.\n     */\n    vars: unknown,\n    /**\n     * The merged context from `onMutate` and the global context. Properties returned by `onMutate` can be `undefined`\n     * if `onMutate` throws.\n     */\n    context:\n      | Partial<Record<keyof UseMutationGlobalContext, never>>\n      // this is the success case where everything is defined\n      // undefined if global onMutate throws\n      | UseMutationGlobalContext,\n  ) => unknown\n\n  /**\n   * Time in ms after which, once the mutation is no longer being used, it will be\n   * garbage collected to free resources. Set to `false` to disable garbage\n   * collection (not recommended).\n   *\n   * @default 60_000 (1 minute)\n   */\n  gcTime?: number | false\n}\n\n/**\n * Default options for `useMutation()`. Modifying this object will affect all mutations.\n */\nexport const USE_MUTATION_DEFAULTS = {\n  gcTime: (1000 * 60) as NonNullable<UseMutationOptions['gcTime']>, // 1 minute\n} satisfies UseMutationOptionsGlobal\n\n/**\n * Options to create a mutation.\n */\nexport interface UseMutationOptions<\n  TData = unknown,\n  TVars = void,\n  TError = ErrorDefault,\n  TContext extends Record<any, any> = _EmptyObject,\n> extends Pick<UseMutationOptionsGlobal, 'gcTime'> {\n  /**\n   * The key of the mutation. If the mutation is successful, it will invalidate the mutation with the same key and refetch it\n   */\n  mutation: (vars: TVars, context: _ReduceContext<NoInfer<TContext>>) => Promise<TData>\n\n  /**\n   * Optional key to identify the mutation globally and access it through other\n   * helpers like `useMutationState()`. If you don't need to reference the\n   * mutation elsewhere, you should ignore this option.\n   */\n  key?: _MutationKey<NoInfer<TVars>>\n\n  /**\n   * Runs before the mutation is executed. **It should be placed before `mutation()` for `context` to be inferred**. It\n   * can return a value that will be passed to `mutation`, `onSuccess`, `onError` and `onSettled`. If it returns a\n   * promise, it will be awaited before running `mutation`.\n   *\n   * @example\n   * ```ts\n   * useMutation({\n   * // must appear before `mutation` for `{ foo: string }` to be inferred\n   * // within `mutation`\n   *   onMutate() {\n   *     return { foo: 'bar' }\n   *   },\n   *   mutation: (id: number, { foo }) => {\n   *     console.log(foo) // bar\n   *     return fetch(`/api/todos/${id}`)\n   *   },\n   *   onSuccess(context) {\n   *     console.log(context.foo) // bar\n   *   },\n   * })\n   * ```\n   */\n  onMutate?: (\n    /**\n     * The variables passed to the mutation.\n     */\n    vars: NoInfer<TVars>,\n    context: UseMutationGlobalContext,\n  ) => _Awaitable<TContext | undefined | void | null>\n\n  /**\n   * Runs if the mutation is successful.\n   */\n  onSuccess?: (\n    /**\n     * The result of the mutation.\n     */\n    data: NoInfer<TData>,\n    /**\n     * The variables passed to the mutation.\n     */\n    vars: NoInfer<TVars>,\n    /**\n     * The merged context from `onMutate` and the global context.\n     */\n    context: UseMutationGlobalContext & _ReduceContext<NoInfer<TContext>>,\n  ) => unknown\n\n  /**\n   * Runs if the mutation encounters an error.\n   */\n  onError?: (\n    /**\n     * The error thrown by the mutation.\n     */\n    error: TError,\n    /**\n     * The variables passed to the mutation.\n     */\n    vars: NoInfer<TVars>,\n    /**\n     * The merged context from `onMutate` and the global context. Properties returned by `onMutate` can be `undefined`\n     * if `onMutate` throws.\n     */\n    context:\n      | (Partial<Record<keyof UseMutationGlobalContext, never>> &\n          Partial<Record<keyof _ReduceContext<NoInfer<TContext>>, never>>)\n      // this is the success case where everything is defined\n      // undefined if global onMutate throws\n      | (UseMutationGlobalContext & _ReduceContext<NoInfer<TContext>>),\n  ) => unknown\n\n  /**\n   * Runs after the mutation is settled, regardless of the result.\n   */\n  onSettled?: (\n    /**\n     * The result of the mutation. `undefined` if the mutation failed.\n     */\n    data: NoInfer<TData> | undefined,\n    /**\n     * The error thrown by the mutation. `undefined` if the mutation was successful.\n     */\n    error: TError | undefined,\n    /**\n     * The variables passed to the mutation.\n     */\n    vars: NoInfer<TVars>,\n    /**\n     * The merged context from `onMutate` and the global context. Properties returned by `onMutate` can be `undefined`\n     * if `onMutate` throws.\n     */\n    context:\n      | (Partial<Record<keyof UseMutationGlobalContext, never>> &\n          Partial<Record<keyof _ReduceContext<NoInfer<TContext>>, never>>)\n      // this is the success case where everything is defined\n      // undefined if global onMutate throws\n      | (UseMutationGlobalContext & _ReduceContext<NoInfer<TContext>>),\n  ) => unknown\n}\n\n/**\n * Global default options for `useMutations()`.\n * @internal\n */\nexport type UseMutationOptionsGlobalDefaults = UseMutationOptionsGlobal &\n  typeof USE_MUTATION_DEFAULTS\n\nexport const USE_MUTATION_OPTIONS_KEY: InjectionKey<UseMutationOptionsGlobalDefaults>\n  = process.env.NODE_ENV !== 'production' ? Symbol('useMutationOptions') : Symbol()\n\n/**\n * Injects the global query options.\n * @internal\n */\nexport const useMutationOptions = (): UseMutationOptionsGlobal =>\n  inject(USE_MUTATION_OPTIONS_KEY, USE_MUTATION_DEFAULTS)\n","import type { ComputedRef, ShallowRef } from 'vue'\nimport type { AsyncStatus, DataState, DataStateStatus } from './data-state'\nimport type { EntryKey } from './entry-keys'\nimport type { ErrorDefault } from './types-extension'\nimport {\n  computed,\n  shallowRef,\n  getCurrentInstance,\n  getCurrentScope,\n  onUnmounted,\n  onScopeDispose,\n} from 'vue'\nimport { useMutationCache } from './mutation-store'\nimport type { UseMutationEntry } from './mutation-store'\nimport { noop } from './utils'\nimport type { _EmptyObject } from './utils'\nimport type { UseMutationOptions } from './mutation-options'\n\n/**\n * Valid keys for a mutation. Similar to query keys.\n *\n * @see {@link EntryKey}\n *\n * @internal\n */\nexport type _MutationKey<TVars> = EntryKey | ((vars: TVars) => EntryKey)\n\n/**\n * Removes the nullish types from the context type to make `A & TContext` work instead of yield `never`.\n *\n * @internal\n */\nexport type _ReduceContext<TContext> = TContext extends void | null | undefined\n  ? _EmptyObject\n  : Record<any, any> extends TContext\n    ? _EmptyObject\n    : TContext\n\n/**\n * Context object returned by a global `onMutate` function that is merged with the context returned by a local\n * `onMutate`.\n * @example\n * ```ts\n * declare module '@pinia/colada' {\n *   export interface UseMutationGlobalContext {\n *     router: Router // from vue-router\n *   }\n * }\n *\n * // add the `router` to the context\n * app.use(MutationPlugin, {\n *   onMutate() {\n *     return { router }\n *   },\n * })\n * ```\n */\nexport interface UseMutationGlobalContext {}\n\n// export const USE_MUTATIONS_DEFAULTS = {} satisfies Partial<UseMutationsOptions>\n\nexport interface UseMutationReturn<TData, TVars, TError> {\n  key?: EntryKey | ((vars: NoInfer<TVars>) => EntryKey)\n\n  /**\n   * The combined state of the mutation. Contains its data, error, and status.\n   * It enables type narrowing based on the {@link UseMutationReturn['status']}.\n   */\n  state: ComputedRef<DataState<TData, TError>>\n\n  /**\n   * The status of the mutation.\n   *\n   * @see {@link DataStateStatus}\n   */\n  status: ShallowRef<DataStateStatus>\n\n  /**\n   * Status of the mutation. Becomes `'loading'` while the mutation is being fetched, is `'idle'` otherwise.\n   */\n  asyncStatus: ShallowRef<AsyncStatus>\n\n  /**\n   * The result of the mutation. `undefined` if the mutation has not been called yet.\n   */\n  data: ShallowRef<TData | undefined>\n\n  /**\n   * The error of the mutation. `null` if the mutation has not been called yet or if it was successful.\n   */\n  error: ShallowRef<TError | null>\n\n  /**\n   * Whether the mutation is currently executing.\n   */\n  isLoading: ComputedRef<boolean>\n\n  /**\n   * The variables passed to the mutation. They are initially `undefined` and change every time the mutation is called.\n   */\n  variables: ShallowRef<TVars | undefined>\n\n  /**\n   * Calls the mutation and returns a promise with the result.\n   *\n   * @param vars - parameters to pass to the mutation\n   */\n  mutateAsync: unknown | void extends TVars ? () => Promise<TData> : (vars: TVars) => Promise<TData>\n\n  /**\n   * Calls the mutation without returning a promise to avoid unhandled promise rejections.\n   *\n   * @param args - parameters to pass to the mutation\n   */\n  mutate: (...args: unknown | void extends TVars ? [] : [vars: TVars]) => void\n\n  /**\n   * Resets the state of the mutation to its initial state.\n   */\n  reset: () => void\n}\n\n/**\n * Setups a mutation.\n *\n * @param options - Options to create the mutation\n *\n * @example\n * ```ts\n * const queryCache = useQueryCache()\n * const { mutate, status, error } = useMutation({\n *   mutation: (id: number) => fetch(`/api/todos/${id}`),\n *   onSuccess() {\n *     queryCache.invalidateQueries('todos')\n *   },\n * })\n * ```\n */\nexport function useMutation<\n  TData,\n  TVars = void,\n  TError = ErrorDefault,\n  TContext extends Record<any, any> = _EmptyObject,\n>(\n  options: UseMutationOptions<TData, TVars, TError, TContext>,\n): UseMutationReturn<TData, TVars, TError> {\n  const mutationCache = useMutationCache()\n  const hasCurrentInstance = getCurrentInstance()\n  const currentEffect = getCurrentScope()\n\n  // always create an initial entry with no key (cannot be computed without vars)\n  const entry = shallowRef<UseMutationEntry<TData, TVars, TError, TContext>>(\n    mutationCache.create(options),\n  )\n\n  // Track the mutation entry if a component or effect scope is available\n  if (hasCurrentInstance) {\n    onUnmounted(() => {\n      mutationCache.untrack(entry.value)\n    })\n  }\n  if (currentEffect) {\n    onScopeDispose(() => {\n      mutationCache.untrack(entry.value)\n    })\n  }\n\n  const state = computed(() => entry.value.state.value)\n  const status = computed(() => state.value.status)\n  const data = computed(() => state.value.data)\n  const error = computed(() => state.value.error)\n  const asyncStatus = computed(() => entry.value.asyncStatus.value)\n  const variables = computed(() => entry.value.vars)\n\n  async function mutateAsync(vars: TVars): Promise<TData> {\n    return mutationCache.mutate(\n      // ensures we reuse the initial empty entry and adapt it or create a new one\n      (entry.value = mutationCache.ensure(entry.value, vars)),\n    )\n  }\n\n  function mutate(vars: NoInfer<TVars>) {\n    mutateAsync(vars).catch(noop)\n  }\n\n  function reset() {\n    entry.value = mutationCache.create(options)\n  }\n\n  return {\n    state,\n    data,\n    isLoading: computed(() => asyncStatus.value === 'loading'),\n    status,\n    variables,\n    asyncStatus,\n    error,\n    // @ts-expect-error: because of the conditional type in UseMutationReturn\n    // it would be nice to find a type-only refactor that works\n    mutate,\n    // @ts-expect-error: same as above\n    mutateAsync,\n    reset,\n  }\n}\n","import { useMutationCache } from './mutation-store'\nimport type { ErrorDefault } from './types-extension'\nimport { useMutation } from './use-mutation'\nimport type { UseMutationReturn } from './use-mutation'\nimport type { UseMutationOptions } from './mutation-options'\nimport type { _EmptyObject } from './utils'\n\n/**\n * Define a mutation with the given options. Similar to `useMutation(options)` but allows you to reuse the mutation in\n * multiple places.\n *\n * @param options - the options to define the mutation\n * @example\n * ```ts\n * const useCreateTodo = defineMutation({\n *   mutation: (todoText: string) =>\n *     fetch('/api/todos', {\n *       method: 'POST',\n *       body: JSON.stringify({ text: todoText }),\n *     }),\n * })\n * ```\n */\nexport function defineMutation<\n  TData,\n  TVars = void,\n  TError = ErrorDefault,\n  TContext extends Record<any, any> = _EmptyObject,\n>(\n  options: UseMutationOptions<TData, TVars, TError, TContext>,\n): () => UseMutationReturn<TData, TVars, TError>\n\n/**\n * Define a mutation with a function setup. Allows to return arbitrary values from the mutation function, create\n * contextual refs, rename the returned values, etc.\n *\n * @param setup - a function to setup the mutation\n * @example\n * ```ts\n * const useCreateTodo = defineMutation(() => {\n *   const todoText = ref('')\n *   const { data, mutate, ...rest } = useMutation({\n *     mutation: () =>\n *       fetch('/api/todos', {\n *         method: 'POST',\n *         body: JSON.stringify({ text: todoText.value }),\n *       }),\n *   })\n *   // expose the todoText ref and rename other methods for convenience\n *   return { ...rest, createTodo: mutate, todo: data, todoText }\n * })\n * ```\n */\nexport function defineMutation<T>(setup: () => T): () => T\nexport function defineMutation(\n  optionsOrSetup: UseMutationOptions | (() => unknown),\n): () => unknown {\n  const setupFn\n    = typeof optionsOrSetup === 'function' ? optionsOrSetup : () => useMutation(optionsOrSetup)\n  return () => {\n    // TODO: provide a way to clean them up `mutationCache.clear()`\n    const mutationCache = useMutationCache()\n    return mutationCache.ensureDefinedMutation(setupFn)\n  }\n}\n","import { setupDevtoolsPlugin } from '@vue/devtools-api'\nimport { watch } from 'vue'\nimport type { App } from 'vue'\nimport type { Pinia } from 'pinia'\nimport { useQueryCache } from '../query-store'\nimport type { AsyncStatus, DataStateStatus } from '../data-state'\n\nconst QUERY_INSPECTOR_ID = 'pinia-colada-queries'\nconst ID_SEPARATOR = '\\0'\n\nfunction debounce(fn: () => void, delay: number) {\n  let timeout: ReturnType<typeof setTimeout>\n  return () => {\n    clearTimeout(timeout)\n    timeout = setTimeout(fn, delay)\n  }\n}\n\nexport function addDevtools(app: App, pinia: Pinia) {\n  const queryCache = useQueryCache(pinia)\n\n  setupDevtoolsPlugin(\n    {\n      id: 'dev.esm.pinia-colada',\n      app,\n      label: 'Pinia Colada',\n      packageName: 'pinia-colada',\n      homepage: 'https://pinia-colada.esm.dev/',\n      logo: 'https://pinia-colada.esm.dev/logo.svg',\n      componentStateTypes: [],\n    },\n    (api) => {\n      const updateQueryInspectorTree = debounce(() => {\n        api.sendInspectorTree(QUERY_INSPECTOR_ID)\n        api.sendInspectorState(QUERY_INSPECTOR_ID)\n      }, 100)\n\n      api.addInspector({\n        id: QUERY_INSPECTOR_ID,\n        label: 'Pinia Queries',\n        icon: 'storage',\n        noSelectionText: 'Select a query entry to inspect it',\n        treeFilterPlaceholder: 'Filter query entries',\n        stateFilterPlaceholder: 'Find within the query entry',\n        actions: [\n          {\n            icon: 'refresh',\n            action: updateQueryInspectorTree,\n            tooltip: 'Sync',\n          },\n        ],\n      })\n\n      let stopWatcher = () => {}\n\n      api.on.getInspectorState((payload) => {\n        if (payload.app !== app) return\n        if (payload.inspectorId === QUERY_INSPECTOR_ID) {\n          const entry = queryCache.getEntries({\n            key: payload.nodeId.split(ID_SEPARATOR),\n            exact: true,\n          })[0]\n          if (!entry) {\n            payload.state = {\n              Error: [\n                {\n                  key: 'error',\n                  value: new Error(`Query entry ${payload.nodeId} not found`),\n                  editable: false,\n                },\n              ],\n            }\n            return\n          }\n\n          stopWatcher()\n          stopWatcher = watch(\n            () => [entry.state.value, entry.asyncStatus.value],\n            () => {\n              api.sendInspectorState(QUERY_INSPECTOR_ID)\n            },\n          )\n\n          const state = entry.state.value\n\n          payload.state = {\n            state: [\n              { key: 'data', value: state.data, editable: true },\n              { key: 'error', value: state.error, editable: true },\n              { key: 'status', value: state.status, editable: true },\n              { key: 'asyncStatus', value: entry.asyncStatus.value, editable: true },\n            ],\n            entry: [\n              { key: 'key', value: entry.key, editable: false },\n              { key: 'options', value: entry.options, editable: true },\n            ],\n          }\n        }\n      })\n\n      api.on.editInspectorState((payload) => {\n        if (payload.app !== app) return\n        if (payload.inspectorId === QUERY_INSPECTOR_ID) {\n          const entry = queryCache.getEntries({\n            key: payload.nodeId.split(ID_SEPARATOR),\n            exact: true,\n          })[0]\n          if (!entry) return\n          const path = payload.path.slice()\n          payload.set(entry, path, payload.state.value)\n          api.sendInspectorState(QUERY_INSPECTOR_ID)\n        }\n      })\n\n      const QUERY_FILTER_RE = /\\b(active|inactive|stale|fresh|exact|loading|idle)\\b/gi\n\n      api.on.getInspectorTree((payload) => {\n        if (payload.app !== app || payload.inspectorId !== QUERY_INSPECTOR_ID) return\n\n        const filters = payload.filter.match(QUERY_FILTER_RE)\n        // strip the filters from the query\n        const filter = (\n          filters ? payload.filter.replace(QUERY_FILTER_RE, '') : payload.filter\n        ).trim()\n\n        const active = filters?.includes('active')\n          ? true\n          : filters?.includes('inactive')\n            ? false\n            : undefined\n        const stale = filters?.includes('stale')\n          ? true\n          : filters?.includes('fresh')\n            ? false\n            : undefined\n        const asyncStatus = filters?.includes('loading')\n          ? 'loading'\n          : filters?.includes('idle')\n            ? 'idle'\n            : undefined\n\n        payload.rootNodes = queryCache\n          .getEntries({\n            active,\n            stale,\n            // TODO: if there is an exact match, we should put it at the top\n            exact: false, // we also filter many\n            predicate(entry) {\n              // filter out by asyncStatus\n              if (asyncStatus && entry.asyncStatus.value !== asyncStatus) return false\n              if (filter) {\n                // TODO: fuzzy match between entry.key.join('/') and the filter\n                return entry.key.some((key) => String(key).includes(filter))\n              }\n              return true\n            },\n          })\n          .map((entry) => {\n            const id = entry.key.join(ID_SEPARATOR)\n            const label = entry.key.join('/')\n            const asyncStatus = entry.asyncStatus.value\n            const state = entry.state.value\n\n            const tags: InspectorNodeTag[] = [\n              ASYNC_STATUS_TAG[asyncStatus],\n              STATUS_TAG[state.status],\n              // useful for testing colors\n              // ASYNC_STATUS_TAG.idle,\n              // ASYNC_STATUS_TAG.fetching,\n              // STATUS_TAG.pending,\n              // STATUS_TAG.success,\n              // STATUS_TAG.error,\n            ]\n            if (!entry.active) {\n              tags.push({\n                label: 'inactive',\n                textColor: 0,\n                backgroundColor: 0xAAAAAA,\n                tooltip: 'The query is not being used anywhere',\n              })\n            }\n            return {\n              id,\n              label,\n              name: label,\n              tags,\n            }\n          })\n      })\n\n      queryCache.$onAction(({ name, after, onError }) => {\n        if (\n          name === 'invalidate' // includes cancel\n          || name === 'fetch' // includes refresh\n          || name === 'setEntryState' // includes set data\n          || name === 'remove'\n          || name === 'untrack'\n          || name === 'track'\n          || name === 'ensure' // includes create\n        ) {\n          updateQueryInspectorTree()\n          after(updateQueryInspectorTree)\n          onError(updateQueryInspectorTree)\n        }\n      })\n\n      // update the devtools too\n      api.notifyComponentUpdate()\n      api.sendInspectorTree(QUERY_INSPECTOR_ID)\n      api.sendInspectorState(QUERY_INSPECTOR_ID)\n    },\n  )\n\n  // TODO: custom tab?\n\n  // addCustomTab({\n  //   name: 'pinia-colada',\n  //   title: 'Pinia Colada',\n  //   icon: 'https://pinia-colada.esm.dev/logo.svg',\n  //   view: {\n  //     type: 'iframe',\n  //     src: '//localhost:',\n  //     persistent: true,\n  //     // type: 'vnode',\n  //     // sfc: DevtoolsPanel,\n  //     // type: 'vnode',\n  //     // vnode: h(DevtoolsPane),\n  //     // vnode: h('p', ['hello world']),\n  //     // vnode: createVNode(DevtoolsPane),\n  //   },\n  //   category: 'modules',\n  // })\n\n  // window.addEventListener('message', (event) => {\n  //   const data = event.data\n  //   if (data != null && typeof data === 'object' && data.id === 'pinia-colada-devtools') {\n  //     console.log('message', event)\n  //   }\n  // })\n}\n\ninterface InspectorNodeTag {\n  label: string\n  textColor: number\n  backgroundColor: number\n  tooltip?: string\n}\n\n/**\n * Tags for the different states of a query\n */\nconst STATUS_TAG: Record<DataStateStatus, InspectorNodeTag> = {\n  pending: {\n    label: 'pending',\n    textColor: 0,\n    backgroundColor: 0xFF9D23,\n    tooltip: `The query hasn't resolved yet`,\n  },\n  success: {\n    label: 'success',\n    textColor: 0,\n    backgroundColor: 0x16C47F,\n    tooltip: 'The query resolved successfully',\n  },\n  error: {\n    label: 'error',\n    textColor: 0,\n    backgroundColor: 0xF93827,\n    tooltip: 'The query rejected with an error',\n  },\n}\n\n/**\n * Tags for the different states of a query\n */\nconst ASYNC_STATUS_TAG: Record<AsyncStatus, InspectorNodeTag> = {\n  idle: {\n    label: 'idle',\n    textColor: 0,\n    backgroundColor: 0xAAAAAA,\n    tooltip: 'The query is not fetching',\n  },\n  loading: {\n    label: 'fetching',\n    textColor: 0xFFFFFF,\n    backgroundColor: 0x578FCA,\n    tooltip: 'The query is currently fetching',\n  },\n}\n","import type { App, Plugin } from 'vue'\nimport type { Pinia } from 'pinia'\nimport type { UseQueryOptionsGlobal } from './query-options'\nimport { USE_QUERY_DEFAULTS, USE_QUERY_OPTIONS_KEY } from './query-options'\nimport { useQueryCache } from './query-store'\nimport type { PiniaColadaPlugin } from './plugins'\nimport { addDevtools } from './devtools/plugin'\nimport { USE_MUTATION_DEFAULTS, USE_MUTATION_OPTIONS_KEY } from './mutation-options'\nimport type { UseMutationOptionsGlobal } from './mutation-options'\n\n/**\n * Options for the Pinia Colada plugin.\n */\nexport interface PiniaColadaOptions {\n  /**\n   * Pinia instance to use. This is only needed if installing before the Pinia plugin.\n   */\n  pinia?: Pinia\n\n  /**\n   * Pinia Colada plugins to install.\n   */\n  plugins?: PiniaColadaPlugin[]\n\n  /**\n   * Global options for queries. These will apply to all `useQuery()`, `defineQuery()`, etc.\n   */\n  queryOptions?: UseQueryOptionsGlobal\n\n  /**\n   * Global options for mutations. These will apply to all `useMutation()`, `defineMutation()`, etc.\n   */\n  mutationOptions?: UseMutationOptionsGlobal\n}\n\n/**\n * Plugin that installs the Query and Mutation plugins alongside some extra plugins.\n *\n * @see {@link QueryPlugin} to only install the Query plugin.\n *\n * @param app - Vue App\n * @param options - Pinia Colada options\n */\nexport const PiniaColada: Plugin<[options?: PiniaColadaOptions]> = (\n  app: App,\n  options: PiniaColadaOptions = {},\n): void => {\n  const {\n    pinia = app.config.globalProperties.$pinia,\n    plugins,\n    queryOptions,\n    mutationOptions = {},\n  } = options\n\n  app.provide(USE_QUERY_OPTIONS_KEY, {\n    ...USE_QUERY_DEFAULTS,\n    ...queryOptions,\n  })\n\n  app.provide(USE_MUTATION_OPTIONS_KEY, {\n    ...USE_MUTATION_DEFAULTS,\n    ...mutationOptions,\n  })\n\n  if (process.env.NODE_ENV !== 'production' && !pinia) {\n    throw new Error(\n      '[@pinia/colada] root pinia plugin not detected. Make sure you install pinia before installing the \"PiniaColada\" plugin or to manually pass the pinia instance.',\n    )\n  }\n\n  if (typeof document !== 'undefined' && process.env.NODE_ENV === 'development') {\n    addDevtools(app, pinia)\n  }\n\n  // install plugins\n  const queryCache = useQueryCache(pinia)\n  plugins?.forEach((plugin) =>\n    plugin({\n      scope: queryCache._s,\n      queryCache,\n      pinia,\n    }),\n  )\n}\n","import type { UseQueryEntry } from '../query-store'\nimport type { PiniaColadaPlugin } from '.'\n\n/**\n * Options for {@link PiniaColadaQueryHooksPlugin}.\n */\nexport interface PiniaColadaQueryHooksPluginOptions {\n  /**\n   * Global handler for when a query is successful.\n   *\n   * @param data - data returned by the query\n   */\n  onSuccess?: <TData = unknown>(data: TData, entry: UseQueryEntry<TData, unknown>) => unknown\n\n  /**\n   * Global handler for when a query is settled (either successfully or with an error). Will await for the `onSuccess`\n   * or `onError` handlers to resolve if they return a promise.\n   *\n   * @param data - data returned by the query if any\n   * @param error - error thrown if any\n   */\n  onSettled?: <TData = unknown, TError = unknown>(\n    data: TData | undefined,\n    error: TError | null,\n    entry: UseQueryEntry<TData, TError>,\n  ) => unknown\n\n  /**\n   * Global error handler for all queries.\n   *\n   * @param error - error thrown\n   */\n  onError?: <TError = unknown>(error: TError, entry: UseQueryEntry<unknown, TError>) => unknown\n}\n\n/**\n * Allows to add global hooks to all queries:\n * - `onSuccess`: called when a query is successful\n * - `onError`: called when a query throws an error\n * - `onSettled`: called when a query is settled (either successfully or with an error)\n * @param options - Pinia Colada Query Hooks plugin options\n *\n * @example\n * ```ts\n * import { PiniaColada, PiniaColadaQueryHooksPlugin } from '@pinia/colada'\n *\n * const app = createApp(App)\n * // app setup with other plugins\n * app.use(PiniaColada, {\n *   plugins: [\n *     PiniaColadaQueryHooksPlugin({\n *       onError(error, entry) {\n *         // ...\n *       },\n *     }),\n *   ],\n * })\n * ```\n */\nexport function PiniaColadaQueryHooksPlugin(\n  options: PiniaColadaQueryHooksPluginOptions,\n): PiniaColadaPlugin {\n  return ({ queryCache }) => {\n    queryCache.$onAction(({ name, after, onError, args }) => {\n      if (name === 'fetch') {\n        const [entry] = args\n        after(async ({ data }) => {\n          await options.onSuccess?.(data, entry)\n          options.onSettled?.(data, null, entry)\n        })\n\n        onError(async (error) => {\n          await options.onError?.(error, entry)\n          options.onSettled?.(undefined, error, entry)\n        })\n      }\n    })\n  }\n}\n"],"mappings":"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","names":["getCurrentInstance","getCurrentScope","onScopeDispose","toValue","getCurrentScope","key","track","getCurrentScope","computed","getCurrentInstance","getCurrentScope","onScopeDispose","toValue","toValue","getCurrentInstance","getCurrentScope","computed","onScopeDispose","entry","getCurrentInstance","getCurrentScope","toValue","onScopeDispose","computed","toValue","computed","toValue","toValue","toValue","defineStore","skipHydrate","customRef","getCurrentScope","shallowRef","inject","defineStore","skipHydrate","customRef","getCurrentScope","shallowRef","computed","shallowRef","getCurrentInstance","getCurrentScope","onUnmounted","onScopeDispose","getCurrentInstance","getCurrentScope","shallowRef","onUnmounted","onScopeDispose","computed","watch","watch","asyncStatus"]}